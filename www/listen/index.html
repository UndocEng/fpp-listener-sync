<!doctype html>

<html>

<head>

  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <title>Listen</title>

  <style>

    body { font-family: system-ui, sans-serif; margin: 0; padding: 18px; background: #111; color: #eee; }

    .header { text-align: center; margin-bottom: 16px; }

    .header img { width: 80px; height: 80px; }

    .header h2 { margin: 8px 0 4px 0; color: #00e5ff; font-size: 36px; font-weight: 700; }

    .small { opacity: .7; font-size: 14px; }

    button { font-size: 22px; padding: 14px 18px; width: 100%; border: 2px solid #00e5ff; border-radius: 10px; background: #222; color: #00e5ff; cursor: pointer; }

    button:disabled { opacity: 0.5; cursor: default; }

    .idle-msg { text-align: center; margin-top: 24px; padding: 20px; border: 1px solid #333; border-radius: 10px; background: #1a1a1a; color: #888; font-size: 16px; }

    .now-playing { text-align: center; margin-top: 16px; padding: 14px; border: 1px solid #00e5ff; border-radius: 10px; background: #0a1a1f; font-size: 18px; color: #00e5ff; }

    .debug-toggle { margin-top: 16px; font-size: 13px; opacity: 0.5; }

    .debug-toggle label { cursor: pointer; }

    .box { margin-top: 8px; padding: 12px; border: 1px solid #333; border-radius: 10px; background: #1a1a1a; font-size: 13px; color: #aaa; }

    .box b { color: #ccc; }

    .err { color: #f44; font-weight: 600; }

    .hidden { display: none; }

  </style>

</head>

<body>

  <div class="header">

    <img src="logo.png" alt="Undocumented Engineer" />

    <h2>Show Audio</h2>

    <p class="small" style="font-size: 11px; opacity: 0.6; margin-top: -4px;" id="version">v1.0.0</p>

    <p class="small">Tap once to enable audio. Keep this page open during the show.</p>

  </div>

  <button id="enableBtn">Enable Audio</button>

  <div id="idleMsg" class="idle-msg">No show is currently broadcasting.</div>

  <div id="nowPlaying" class="now-playing hidden">&#9835; Now Playing: <span id="trackName">-</span></div>

  <div class="err" id="fetchErr"></div>

  <div class="err" id="playErr"></div>

  <div class="debug-toggle"><label><input type="checkbox" id="debugCheck" /> Show Debug Data</label> &nbsp; <label><input type="checkbox" id="logCheck" /> Enable Logging</label></div>

  <div id="debugBox" class="box hidden">

    <div><b>Transport:</b> <span id="transport">-</span></div>

    <div><b>RTT:</b> <span id="rtt">-</span> ms</div>

    <div><b>Clock Offset:</b> <span id="offset">-</span> ms</div>

    <div><b>Sequence:</b> <span id="seq">-</span></div>

    <div><b>State:</b> <span id="state">-</span></div>

    <div><b>Target:</b> <span id="target">-</span> ms</div>

    <div><b>Local:</b> <span id="local">-</span> ms</div>

    <div><b>Error:</b> <span id="err">-</span> ms</div>

    <div><b>Avg Error (5s):</b> <span id="avgErr5s">-</span> ms</div>

    <div><b>Avg Error (all):</b> <span id="avgErrAll">-</span> ms</div>

    <div><b>Effective Rate:</b> <span id="effRate">-</span></div>

    <div><b>Buffered:</b> <span id="buffered">-</span> s</div>

    <div><b>Last Correction:</b> <span id="lastCorrection">-</span></div>

    <div><b>Threshold:</b> <select id="thresholdSelect" style="background:#222;color:#aaa;border:1px solid #555;font-size:13px;"><option value="200">200 ms</option><option value="300" selected>300 ms</option><option value="500">500 ms</option></select></div>

  </div>

  <div id="logControls" class="hidden" style="margin-top:8px;text-align:right;">
    <span id="logStatus" style="font-size:11px;color:#f90;margin-right:8px;"></span>
    <button id="resumeLogBtn" style="font-size:12px;padding:4px 10px;width:auto;border:1px solid #555;background:#222;color:#aaa;display:none;">Resume Log</button>
    <button id="copyLogBtn" style="font-size:12px;padding:4px 10px;width:auto;border:1px solid #555;background:#222;color:#aaa;">Copy Log</button>
    <button id="clearLogBtn" style="font-size:12px;padding:4px 10px;width:auto;border:1px solid #555;background:#222;color:#aaa;">Clear Log</button>
  </div>
  <div id="logBox" class="box hidden" style="max-height:200px;overflow-y:auto;font-family:monospace;font-size:11px;white-space:pre-wrap;"></div>

  <audio id="audio" preload="auto" playsinline></audio>

<script>

// --- DOM References ---
const enableBtn=document.getElementById('enableBtn'),
audio=document.getElementById('audio'),
idleMsg=document.getElementById('idleMsg'),
nowPlaying=document.getElementById('nowPlaying'),
trackName=document.getElementById('trackName'),
pollEl=document.getElementById('transport'),
fetchErrEl=document.getElementById('fetchErr'),
playErrEl=document.getElementById('playErr'),
seqEl=document.getElementById('seq'),
stateEl=document.getElementById('state'),
targetEl=document.getElementById('target'),
localEl=document.getElementById('local'),
errEl=document.getElementById('err'),
avgErr5sEl=document.getElementById('avgErr5s'),
avgErrAllEl=document.getElementById('avgErrAll'),
effRateEl=document.getElementById('effRate'),
bufferedEl=document.getElementById('buffered'),
lastCorrectionEl=document.getElementById('lastCorrection'),
rttEl=document.getElementById('rtt'),
offsetEl=document.getElementById('offset'),
debugCheck=document.getElementById('debugCheck'),
debugBox=document.getElementById('debugBox'),
thresholdSelect=document.getElementById('thresholdSelect');

// --- State ---
let enabled=false, currentBase="", pollTimer=null, haveMetadata=false, needInitialSeek=false, lastSeekMs=0, settleUntil=0, syncBusy=false;
let logFrozen=false, wasPlaying=false;
let pendingMsg=null, playAttempting=false;

// --- WebSocket ---
const WS_RECONNECT_MS=2000;
const WS_PING_INTERVAL_MS=3000;
const HTTP_POLL_MS=250;

let ws=null, wsConnected=false, wsPingTimer=null, wsReconnectTimer=null;

// --- Clock offset estimation ---
let clockOffset=0, clockOffsetValid=false;
const RTT_HISTORY_SIZE=5;
const OFFSET_HISTORY_SIZE=8;
let rttHistory=[];
let offsetHistory=[];

// --- Simple Sync: scheduled start + 5s check ---
const CHECK_INTERVAL_MS=5000;
const LEAD_MS=2000;
const SEEK_COOLDOWN_MS=3000;
let seekThresholdMs=300;
let lastCheckMs=0;
let checkSamples=[];
let errHistoryAll=[];
let awaitingStart=false;
let scheduledStartTarget=0;
let lastCorrectionMs=0;
let logThrottle=0;
let lastSampledFppPos=-1; // only sample error when FPP pos_ms changes (avoids 1s quantization sawtooth)

// --- Effective rate measurement ---
let effRateWallMs=0, effRateLocalMs=0, lastEffRate=0;

// --- Threshold persistence ---
const THRESHOLD_KEY='fpp-sync-threshold';
try{
  const saved=localStorage.getItem(THRESHOLD_KEY);
  if(saved&&['200','300','500'].includes(saved)){
    seekThresholdMs=parseInt(saved);
    thresholdSelect.value=saved;
  }
}catch(e){}
thresholdSelect.addEventListener('change',()=>{
  seekThresholdMs=parseInt(thresholdSelect.value);
  try{localStorage.setItem(THRESHOLD_KEY,thresholdSelect.value);}catch(e){}
});

// --- Helpers ---
function clamp(v,lo,hi){return Math.max(lo,Math.min(hi,v));}

const logBox=document.getElementById('logBox');
const LOG_MAX=200;
let logCount=0;
const logCheck=document.getElementById('logCheck');
function log(msg){
  if(!logCheck.checked||logFrozen)return;
  const t=new Date();
  const ts=t.toTimeString().slice(0,8)+'.'+String(t.getMilliseconds()).padStart(3,'0');
  const line=ts+' '+msg+'\n';
  logBox.textContent+=line;
  logCount++;
  if(logCount>LOG_MAX){
    const lines=logBox.textContent.split('\n');
    logBox.textContent=lines.slice(-LOG_MAX).join('\n');
    logCount=LOG_MAX;
  }
  logBox.scrollTop=logBox.scrollHeight;
}

// --- Server-side reporting (always on, minimal overhead) ---
const REPORT_INTERVAL_MS=2000;
let lastReportMs=0;
let lastRawPosMs=0, lastTargetMs=0, lastLocalMs=0;
function sendReport(event,errMs,rate){
  if(!ws||ws.readyState!==WebSocket.OPEN)return;
  const now=Date.now();
  const immediate=event==='START'||event==='CORRECTION'||event==='TRACK'||event==='INITIAL_SEEK'||event==='STOP';
  if(!immediate&&(now-lastReportMs)<REPORT_INTERVAL_MS)return;
  lastReportMs=now;
  ws.send(JSON.stringify({
    type:'report',
    event:event,
    fpp:Math.round(lastRawPosMs),
    target:Math.round(lastTargetMs),
    local:Math.round(lastLocalMs),
    err:Math.round(errMs||0),
    rate:Number((rate||1.0).toFixed(4)),
    eff:Number((lastEffRate||0).toFixed(3)),
    offset:Math.round(clockOffset),
    track:currentBase||''
  }));
}

const logControls=document.getElementById('logControls');
debugCheck.addEventListener('change',()=>{
  debugBox.classList.toggle('hidden',!debugCheck.checked);
});
logCheck.addEventListener('change',()=>{
  const show=logCheck.checked;
  logBox.classList.toggle('hidden',!show);
  logControls.classList.toggle('hidden',!show);
});
document.getElementById('copyLogBtn').onclick=()=>{
  if(navigator.clipboard){navigator.clipboard.writeText(logBox.textContent).then(()=>{document.getElementById('copyLogBtn').textContent='Copied!';setTimeout(()=>{document.getElementById('copyLogBtn').textContent='Copy Log';},1500);});}
};
document.getElementById('clearLogBtn').onclick=()=>{logBox.textContent='';logCount=0;logFrozen=false;document.getElementById('logStatus').textContent='';document.getElementById('resumeLogBtn').style.display='none';};
document.getElementById('resumeLogBtn').onclick=()=>{logFrozen=false;document.getElementById('logStatus').textContent='';document.getElementById('resumeLogBtn').style.display='none';log('--- LOG RESUMED ---');};
audio.addEventListener('loadedmetadata',()=>{haveMetadata=true;log('METADATA loaded');});
audio.addEventListener('error',()=>{playErrEl.textContent="No matching audio file detected";log('AUDIO ERROR');});

// === Shared Clock Offset ===

function updateClockOffset(serverTs, clientSendTs, rtt){
  const sample=serverTs-clientSendTs-(rtt/2);

  offsetHistory.push(sample);
  if(offsetHistory.length>OFFSET_HISTORY_SIZE)offsetHistory.shift();

  const sorted=[...offsetHistory].sort((a,b)=>a-b);
  const median=sorted[Math.floor(sorted.length/2)];

  if(!clockOffsetValid){
    clockOffset=median;
    clockOffsetValid=true;
  }else{
    clockOffset=clockOffset*0.7+median*0.3;
  }
  offsetEl.textContent=Math.round(clockOffset);
}

// === WebSocket Connection ===

function connectWebSocket(){
  if(ws&&(ws.readyState===WebSocket.CONNECTING||ws.readyState===WebSocket.OPEN))return;
  const wsUrl='ws://'+location.hostname+'/ws';
  try{ws=new WebSocket(wsUrl);}catch(e){startHttpFallback();return;}

  ws.onopen=()=>{
    wsConnected=true;
    stopHttpPolling();
    offsetHistory=[];
    clockOffsetValid=false;
    clockOffset=0;
    pollEl.textContent='WebSocket connected';
    fetchErrEl.textContent='';
    wsPingTimer=setInterval(sendPing,WS_PING_INTERVAL_MS);
    sendPing();
    log('WS CONNECTED, offset reset');
  };

  ws.onmessage=(event)=>{
    try{
      const data=JSON.parse(event.data);
      if(data.type==='pong'){
        handlePong(data);
      }else if(data.state!==undefined){
        sync(data);
      }
    }catch(e){}
  };

  ws.onclose=()=>{
    log('WS DISCONNECTED, falling back to HTTP');
    wsConnected=false;
    if(wsPingTimer){clearInterval(wsPingTimer);wsPingTimer=null;}
    pollEl.textContent='WS disconnected, HTTP fallback';
    startHttpFallback();
    if(wsReconnectTimer)clearTimeout(wsReconnectTimer);
    wsReconnectTimer=setTimeout(connectWebSocket,WS_RECONNECT_MS);
  };

  ws.onerror=()=>{};
}

function sendPing(){
  if(ws&&ws.readyState===WebSocket.OPEN){
    ws.send(JSON.stringify({type:'ping',client_ts:Date.now()}));
  }
}

function handlePong(data){
  const now=Date.now();
  const clientTs=data.client_ts;
  const serverTs=data.server_ts;
  const rtt=now-clientTs;

  if(rtt>0&&rtt<500){
    rttHistory.push(rtt);
    if(rttHistory.length>RTT_HISTORY_SIZE)rttHistory.shift();
    rttEl.textContent=rtt;
    updateClockOffset(serverTs,clientTs,rtt);
    log('PONG rtt='+rtt+'ms offset='+Math.round(clockOffset)+'ms');
  }else{
    log('PONG REJECTED rtt='+rtt+'ms (out of range)');
  }
}

// === HTTP Fallback Polling ===

function startHttpFallback(){
  if(pollTimer)return;
  pollTimer=setInterval(pollOnce,HTTP_POLL_MS);
  pollOnce();
}

function stopHttpPolling(){
  if(pollTimer){clearInterval(pollTimer);pollTimer=null;}
}

async function pollOnce(){
  if(!enabled)return;
  const t0=Date.now();
  try{
    const url=location.origin+'/listen/status.php?ts='+Date.now();
    const r=await fetch(url,{cache:'no-store'});
    if(!r.ok)throw new Error('HTTP '+r.status);
    const msg=await r.json();
    const t1=Date.now();
    const rtt=t1-t0;
    if(!wsConnected)pollEl.textContent='HTTP ok ('+rtt+' ms)';
    fetchErrEl.textContent='';

    if(msg.server_ms&&rtt>0&&rtt<500){
      updateClockOffset(msg.server_ms,t0,rtt);
      if(!wsConnected)rttEl.textContent=rtt;
    }

    sync(msg);
  }catch(e){
    if(!wsConnected)pollEl.textContent='HTTP FAILED';
    fetchErrEl.textContent='Fetch error: '+(e?.message||e);
  }
}

// === Audio Playback ===

async function safePlay(){
  try{
    const p=audio.play();
    if(p&&typeof p.catch==='function'){await p;}
    playErrEl.textContent='';
  }catch(e){
    playErrEl.textContent='Audio playback blocked: '+(e?.message||e);
  }
}

// === Enable Button ===

enableBtn.onclick=()=>{
  enabled=true;
  enableBtn.disabled=true;
  enableBtn.textContent='Audio Enabled';
  pollEl.textContent='Connecting...';

  connectWebSocket();
  startHttpFallback();

  // Audio unlock gesture
  try{
    audio.muted=true;
    const p=audio.play();
    if(p&&typeof p.then==='function'){
      p.then(()=>{audio.pause();audio.currentTime=0;audio.muted=false;})
      .catch(()=>{audio.muted=false;});
    }else{audio.muted=false;}
  }catch(e){audio.muted=false;}
};

document.addEventListener('visibilitychange',()=>{
  if(document.visibilityState==='visible'&&enabled&&!wsConnected){
    connectWebSocket();
  }
});

// === Scheduled Start Helper ===
// Seeks ahead of FPP, waits for seeked event, sets awaitingStart flag.
// The sync loop then waits for FPP to catch up and presses play at the right moment.

function beginScheduledStart(targetSec){
  const leadSec=LEAD_MS/1000;
  const seekTo=clamp(targetSec+leadSec,0,audio.duration-0.05);
  audio.pause();
  audio.currentTime=seekTo;

  const onSeeked=()=>{
    audio.removeEventListener('seeked',onSeeked);
    scheduledStartTarget=audio.currentTime;
    awaitingStart=true;
    log('SCHEDULED seek landed='+Math.round(scheduledStartTarget*1000)+'ms (target was '+Math.round(seekTo*1000)+'ms)');
  };
  audio.addEventListener('seeked',onSeeked);
}

// === Sync Algorithm ===

async function sync(msg){
  pendingMsg=msg;
  if(syncBusy)return;
  syncBusy=true;
  try{
    while(pendingMsg){
      const m=pendingMsg;
      pendingMsg=null;
      await syncInner(m);
    }
  }finally{syncBusy=false;}
}

async function syncInner(msg){
  seqEl.textContent=msg.base||'-';
  stateEl.textContent=msg.state||'-';
  targetEl.textContent=msg.pos_ms??'-';

  if(msg.state==='stop'||!msg.base){
    idleMsg.classList.remove('hidden');
    nowPlaying.classList.add('hidden');
    playErrEl.textContent='';
  }else{
    idleMsg.classList.add('hidden');
    nowPlaying.classList.remove('hidden');
    trackName.textContent=msg.base;
  }

  // Track change
  if(msg.base&&msg.base!==currentBase){
    logBox.textContent='';logCount=0;logFrozen=false;
    document.getElementById('logStatus').textContent='';
    document.getElementById('resumeLogBtn').style.display='none';
    log('TRACK CHANGE: '+msg.base+' src='+msg.mp3_url);
    sendReport('TRACK',0,1.0);
    currentBase=msg.base;
    haveMetadata=false;
    needInitialSeek=true;
    awaitingStart=false;
    audio.playbackRate=1.0;
    audio.src=msg.mp3_url||'';
    audio.load();
    checkSamples=[];
    errHistoryAll=[];
    effRateWallMs=0;
    lastCheckMs=0;
    lastSampledFppPos=-1;
  }

  // Stop
  if(msg.state==='stop'){
    if(wasPlaying){
      log('STATE: stop');
      sendReport('STOP',0,1.0);
      if(logCheck.checked){
        logFrozen=true;
        document.getElementById('logStatus').textContent='Log frozen (song ended)';
        document.getElementById('resumeLogBtn').style.display='';
      }
    }
    audio.pause();
    audio.currentTime=0;
    audio.playbackRate=1.0;
    checkSamples=[];
    errHistoryAll=[];
    needInitialSeek=false;
    awaitingStart=false;
    wasPlaying=false;
    return;
  }

  // Pause
  if(msg.state==='pause'){
    log('STATE: pause');
    audio.pause();
    audio.playbackRate=1.0;
    checkSamples=[];
    errHistoryAll=[];
    needInitialSeek=false;
    awaitingStart=false;
    return;
  }

  wasPlaying=true;

  // --- Time calculation with clock offset ---
  const nowMs=Date.now();
  const serverMs=Number(msg.server_ms);
  const rawPosMs=Number(msg.pos_ms||0);

  let targetMs=rawPosMs;
  const serverOk=Number.isFinite(serverMs)&&serverMs>1e12&&Math.abs(nowMs-serverMs)<300000;
  if(serverOk){
    let elapsed;
    if(clockOffsetValid){
      elapsed=(nowMs+clockOffset)-serverMs;
    }else{
      elapsed=nowMs-serverMs;
    }
    if(!Number.isFinite(elapsed))elapsed=0;
    elapsed=clamp(elapsed,0,1500);
    targetMs=rawPosMs+elapsed;
  }else{
    log('SERVER_MS INVALID: '+serverMs+' nowMs='+nowMs+' diff='+Math.abs(nowMs-serverMs));
  }

  const targetSec=targetMs/1000.0;
  const localSec=audio.currentTime||0;
  const errMs=(targetSec-localSec)*1000.0;

  lastRawPosMs=rawPosMs;
  lastTargetMs=targetMs;
  lastLocalMs=localSec*1000;

  // Update debug display
  localEl.textContent=Math.round(localSec*1000);
  targetEl.textContent=Math.round(targetMs);

  // Update last correction display
  if(lastCorrectionMs>0){
    const ago=Math.round((nowMs-lastCorrectionMs)/1000);
    lastCorrectionEl.textContent=ago+'s ago';
  }

  // --- Scheduled start: waiting for metadata before we can seek ---
  if(needInitialSeek&&haveMetadata){
    needInitialSeek=false;
    log('INITIAL: scheduling start, target='+Math.round(targetMs)+'ms');
    sendReport('INITIAL_SEEK',errMs,1.0);
    beginScheduledStart(targetSec);
    return;
  }

  if(needInitialSeek){
    // Still waiting for metadata
    return;
  }

  // --- Awaiting scheduled start: paused, waiting for FPP to reach our position ---
  if(awaitingStart){
    const waitingForMs=scheduledStartTarget*1000;
    const remainMs=waitingForMs-targetMs;

    // FPP jumped backward past our target (operator rewind) — re-schedule
    if(remainMs>LEAD_MS+1000){
      log('RESCHEDULE: FPP jumped back, remain='+Math.round(remainMs)+'ms');
      beginScheduledStart(targetSec);
      return;
    }

    if(targetMs>=waitingForMs){
      // FPP has reached our position — GO!
      awaitingStart=false;
      log('PLAY! landed='+Math.round(waitingForMs)+'ms fpp='+Math.round(targetMs)+'ms');
      lastCheckMs=nowMs;
      checkSamples=[];
      settleUntil=nowMs+1500;
      effRateWallMs=nowMs;
      effRateLocalMs=scheduledStartTarget*1000;
      playAttempting=true;
      safePlay().finally(()=>{playAttempting=false;});
      sendReport('START',0,1.0);
    }else{
      // Still waiting
      errEl.textContent='(waiting '+Math.round(remainMs)+'ms)';
      if(++logThrottle%20===0)log('WAITING remain='+Math.round(remainMs)+'ms target='+Math.round(targetMs)+'ms landed='+Math.round(waitingForMs)+'ms');
    }
    return;
  }

  // --- Settle period after play starts ---
  if(nowMs<settleUntil){
    errEl.textContent='(settling)';
    if(++logThrottle%10===0)log('SETTLE remaining='+(settleUntil-nowMs)+'ms');
    return;
  }

  // --- Start playback if somehow paused (e.g. browser tab switch) ---
  if(audio.paused&&!playAttempting){
    log('PLAY resuming (was paused)');
    playAttempting=true;
    safePlay().finally(()=>{playAttempting=false;});
  }

  // --- Normal operation ---
  errEl.textContent=Math.round(errMs);
  audio.playbackRate=1.0;

  // Collect error samples ONLY when FPP pos_ms changes (at the 1-second tick boundary).
  // FPP reports pos_ms in 1-second steps. Between ticks, target stays flat while
  // audio.currentTime advances, creating a ~900ms sawtooth artifact. Sampling only
  // at tick boundaries gives clean readings (~1 per second, no sawtooth bias).
  if(rawPosMs!==lastSampledFppPos){
    lastSampledFppPos=rawPosMs;
    checkSamples.push(errMs);
    errHistoryAll.push(errMs);
    if(errHistoryAll.length>100)errHistoryAll.shift();
  }

  const avgCheck=checkSamples.length>0?(checkSamples.reduce((a,b)=>a+b,0)/checkSamples.length):0;
  const avgAll=errHistoryAll.length>0?(errHistoryAll.reduce((a,b)=>a+b,0)/errHistoryAll.length):0;
  avgErr5sEl.textContent=Math.round(avgCheck);
  avgErrAllEl.textContent=Math.round(avgAll);

  let bufferedSec=0;
  if(audio.buffered.length>0){bufferedSec=audio.buffered.end(audio.buffered.length-1)-localSec;}
  bufferedEl.textContent=bufferedSec.toFixed(1);

  if(!haveMetadata||!Number.isFinite(audio.duration)||audio.duration<=0){
    return;
  }

  // Measure effective rate for diagnostics
  if(effRateWallMs>0){
    const dWall=nowMs-effRateWallMs;
    const dLocal=(localSec*1000)-effRateLocalMs;
    if(dWall>1000){
      lastEffRate=dLocal/dWall;
      effRateEl.textContent=lastEffRate.toFixed(4);
      effRateWallMs=nowMs;
      effRateLocalMs=localSec*1000;
    }
  }else{
    effRateWallMs=nowMs;
    effRateLocalMs=localSec*1000;
  }

  // --- 5-second check ---
  if(lastCheckMs===0)lastCheckMs=nowMs;

  if((nowMs-lastCheckMs)>=CHECK_INTERVAL_MS){
    const avgErr=checkSamples.length>0?(checkSamples.reduce((a,b)=>a+b,0)/checkSamples.length):0;
    log('CHECK avg='+Math.round(avgErr)+'ms samples='+checkSamples.length+' threshold='+seekThresholdMs+'ms');

    if(Math.abs(avgErr)>seekThresholdMs&&(nowMs-lastSeekMs)>SEEK_COOLDOWN_MS){
      log('CORRECTION avgErr='+Math.round(avgErr)+'ms — scheduling resync');
      sendReport('CORRECTION',avgErr,1.0);
      lastSeekMs=nowMs;
      lastCorrectionMs=nowMs;
      errHistoryAll=[];
      lastSampledFppPos=-1;
      beginScheduledStart(targetSec);
      checkSamples=[];
      lastCheckMs=nowMs;
      return;
    }

    checkSamples=[];
    lastCheckMs=nowMs;
  }

  // Periodic logging and reporting
  if(++logThrottle%20===0)log('SYNC err='+Math.round(errMs)+'ms avg5s='+Math.round(avgCheck)+'ms avgAll='+Math.round(avgAll)+'ms eff='+lastEffRate.toFixed(4));
  sendReport('SYNC',errMs,1.0);
}

// Fetch and display version (cache-busting)
fetch('/listen/version.php?t='+Date.now()).then(r=>r.text()).then(v=>document.getElementById('version').textContent='v'+v.trim()).catch(()=>{});

</script>

</body>

</html>
