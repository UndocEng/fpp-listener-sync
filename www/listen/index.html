<!doctype html>

<html>

<head>

  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <title>Listen</title>

  <style>

    body { font-family: system-ui, sans-serif; margin: 0; padding: 18px; background: #111; color: #eee; }

    .header { text-align: center; margin-bottom: 16px; }

    .header img { width: 80px; height: 80px; }

    .header h2 { margin: 8px 0 4px 0; color: #00e5ff; font-size: 36px; font-weight: 700; }

    .small { opacity: .7; font-size: 14px; }

    button { font-size: 22px; padding: 14px 18px; width: 100%; border: 2px solid #00e5ff; border-radius: 10px; background: #222; color: #00e5ff; cursor: pointer; }

    button:disabled { opacity: 0.5; cursor: default; }

    .idle-msg { text-align: center; margin-top: 24px; padding: 20px; border: 1px solid #333; border-radius: 10px; background: #1a1a1a; color: #888; font-size: 16px; }

    .now-playing { text-align: center; margin-top: 16px; padding: 14px; border: 1px solid #00e5ff; border-radius: 10px; background: #0a1a1f; font-size: 18px; color: #00e5ff; }

    .debug-toggle { margin-top: 16px; font-size: 13px; opacity: 0.5; }

    .debug-toggle label { cursor: pointer; }

    .box { margin-top: 8px; padding: 12px; border: 1px solid #333; border-radius: 10px; background: #1a1a1a; font-size: 13px; color: #aaa; }

    .box b { color: #ccc; }

    .err { color: #f44; font-weight: 600; }

    .hidden { display: none; }

  </style>

</head>

<body>

  <div class="header">

    <img src="logo.png" alt="Undocumented Engineer" />

    <h2>Show Audio</h2>

    <p class="small" style="font-size: 11px; opacity: 0.6; margin-top: -4px;" id="version">v1.0.0</p>

    <p class="small">Tap once to enable audio. Keep this page open during the show.</p>

  </div>

  <button id="enableBtn">Enable Audio</button>

  <div id="idleMsg" class="idle-msg">No show is currently broadcasting.</div>

  <div id="nowPlaying" class="now-playing hidden">&#9835; Now Playing: <span id="trackName">-</span></div>

  <div class="err" id="fetchErr"></div>

  <div class="err" id="playErr"></div>

  <div class="debug-toggle"><label><input type="checkbox" id="debugCheck" /> Show Debug Data</label></div>

  <div id="debugBox" class="box hidden">

    <div><b>Poll:</b> <span id="poll">not started</span></div>

    <div><b>Sequence:</b> <span id="seq">-</span></div>

    <div><b>State:</b> <span id="state">-</span></div>

    <div><b>Target:</b> <span id="target">-</span> ms</div>

    <div><b>Local:</b> <span id="local">-</span> ms</div>

    <div><b>Error:</b> <span id="err">-</span> ms</div>

    <div><b>Avg Error (2s):</b> <span id="avgErr2s">-</span> ms</div>

    <div><b>Avg Error (all):</b> <span id="avgErrAll">-</span> ms</div>

    <div><b>Initial Error (0.5s):</b> <span id="initErr">-</span> ms</div>

    <div><b>Playback Rate:</b> <span id="playRate">1.0</span></div>

    <div><b>Buffered:</b> <span id="buffered">-</span> s</div>

  </div>

  <audio id="audio" preload="auto" playsinline></audio>

<script>

const enableBtn=document.getElementById('enableBtn'),audio=document.getElementById('audio'),idleMsg=document.getElementById('idleMsg'),nowPlaying=document.getElementById('nowPlaying'),trackName=document.getElementById('trackName'),pollEl=document.getElementById('poll'),fetchErrEl=document.getElementById('fetchErr'),playErrEl=document.getElementById('playErr'),seqEl=document.getElementById('seq'),stateEl=document.getElementById('state'),targetEl=document.getElementById('target'),localEl=document.getElementById('local'),errEl=document.getElementById('err'),avgErr2sEl=document.getElementById('avgErr2s'),avgErrAllEl=document.getElementById('avgErrAll'),initErrEl=document.getElementById('initErr'),playRateEl=document.getElementById('playRate'),bufferedEl=document.getElementById('buffered'),debugCheck=document.getElementById('debugCheck'),debugBox=document.getElementById('debugBox');

let enabled=false,currentBase="",pollTimer=null,haveMetadata=false,needInitialSeek=false;

// Clock offset tracking with RTT compensation
let clockOffsetMs=0;
let clockOffsetInit=false;
let rttMs=0;
let hardSeekStrike=0;

// PI Controller state
let integralError=0;
let lastPlaybackRate=1.0;

function clamp(v,lo,hi){return Math.max(lo,Math.min(hi,v));}

debugCheck.addEventListener('change',()=>{debugBox.classList.toggle('hidden',!debugCheck.checked);});

audio.addEventListener('loadedmetadata',()=>{haveMetadata=true;});

audio.addEventListener('error',()=>{playErrEl.textContent="No matching audio file detected";});

enableBtn.onclick=()=>{enabled=true;enableBtn.disabled=true;enableBtn.textContent="Audio Enabled";pollEl.textContent="POLLING...";if(pollTimer)clearInterval(pollTimer);pollTimer=setInterval(pollOnce,250);pollOnce();try{audio.muted=true;const p=audio.play();if(p&&typeof p.then==='function'){p.then(()=>{audio.pause();audio.currentTime=0;audio.muted=false;}).catch((e)=>{audio.muted=false;});}else{audio.muted=false;}}catch(e){audio.muted=false;}};

async function pollOnce(){
if(!enabled)return;
const tSend=performance.now();
const tSendWall=Date.now();
try{
const url=`${location.origin}/listen/status.php?ts=${Date.now()}`;
const r=await fetch(url,{cache:'no-store'});
if(!r.ok)throw new Error(`HTTP ${r.status}`);
const msg=await r.json();
const tRecv=performance.now();
const rtt=(tRecv-tSend);
rttMs=rttMs?(0.85*rttMs+0.15*rtt):rtt;
// Compute clock offset with half-RTT correction
const serverMs=Number(msg.server_ms);
if(Number.isFinite(serverMs)&&serverMs>1000000000000){
const estClientAtServerSample=tSendWall+(rtt/2);
const newOffset=serverMs-estClientAtServerSample;
clockOffsetMs=clockOffsetInit?(0.90*clockOffsetMs+0.10*newOffset):newOffset;
clockOffsetInit=true;
}
pollEl.textContent=`ok (${Math.round(rtt)} ms)`;
fetchErrEl.textContent="";
sync(msg);
}catch(e){
pollEl.textContent="FAILED";
fetchErrEl.textContent="Fetch error: "+(e?.message||e);
}
}

async function safePlay(){try{const p=audio.play();if(p&&typeof p.catch==='function'){await p;}playErrEl.textContent="";}catch(e){playErrEl.textContent="Audio playback blocked: "+(e?.message||e);}}

// Position averaging for smooth sync
let posHistory=[];
const POS_HISTORY_SIZE=2;

// Error tracking for statistics
let errHistory2s=[];
let errHistoryAll=[];
let errHistoryInit=[];
let initErrCalculated=false;
const ERR_2S_SIZE=8; // 2 seconds at 250ms poll rate
const ERR_INIT_SIZE=2; // First 500ms (2 polls at 250ms)

async function sync(msg){seqEl.textContent=msg.base||"-";stateEl.textContent=msg.state||"-";targetEl.textContent=msg.pos_ms??"-";if(msg.state==="stop"||!msg.base){idleMsg.classList.remove('hidden');nowPlaying.classList.add('hidden');playErrEl.textContent="";}else{idleMsg.classList.add('hidden');nowPlaying.classList.remove('hidden');trackName.textContent=msg.base;}if(msg.base&&msg.base!==currentBase){currentBase=msg.base;haveMetadata=false;needInitialSeek=true;syncAttempts=0;audio.playbackRate=1.0;audio.src=msg.mp3_url||"";audio.load();posHistory=[];errHistory2s=[];errHistoryAll=[];errHistoryInit=[];initErrCalculated=false;integralError=0;lastPlaybackRate=1.0;}if(msg.state==="stop"){audio.pause();audio.currentTime=0;audio.playbackRate=1.0;posHistory=[];errHistory2s=[];errHistoryAll=[];errHistoryInit=[];initErrCalculated=false;needInitialSeek=false;syncAttempts=0;integralError=0;lastPlaybackRate=1.0;return;}if(msg.state==="pause"){audio.pause();audio.playbackRate=1.0;posHistory=[];errHistory2s=[];errHistoryAll=[];errHistoryInit=[];initErrCalculated=false;needInitialSeek=false;syncAttempts=0;integralError=0;lastPlaybackRate=1.0;return;}// Use clock offset to predict server time more accurately
const nowWall=Date.now();
const serverNow=clockOffsetInit?(nowWall+clockOffsetMs):nowWall;
let sampleServerMs=Number(msg.server_ms);
if(!Number.isFinite(sampleServerMs)||sampleServerMs<1000000000000){sampleServerMs=serverNow;}
const basePosMs=Number(msg.pos_ms||0);
const smoothPosMs=basePosMs+(serverNow-sampleServerMs);
posHistory.push(smoothPosMs);
if(posHistory.length>POS_HISTORY_SIZE)posHistory.shift();
const avgPosMs=posHistory.reduce((a,b)=>a+b,0)/posHistory.length;
const targetSec=avgPosMs/1000.0;const localSec=audio.currentTime||0;const errMs=(targetSec-localSec)*1000.0;localEl.textContent=Math.round(localSec*1000);errEl.textContent=Math.round(errMs);errHistory2s.push(errMs);if(errHistory2s.length>ERR_2S_SIZE)errHistory2s.shift();errHistoryAll.push(errMs);const avgErr2s=errHistory2s.length>0?(errHistory2s.reduce((a,b)=>a+b,0)/errHistory2s.length):0;const avgErrAll=errHistoryAll.length>0?(errHistoryAll.reduce((a,b)=>a+b,0)/errHistoryAll.length):0;avgErr2sEl.textContent=Math.round(avgErr2s);avgErrAllEl.textContent=Math.round(avgErrAll);if(!initErrCalculated&&errHistoryInit.length<ERR_INIT_SIZE){errHistoryInit.push(errMs);}if(!initErrCalculated&&errHistoryInit.length>=ERR_INIT_SIZE){const avgInitErr=errHistoryInit.reduce((a,b)=>a+b,0)/errHistoryInit.length;initErrEl.textContent=Math.round(avgInitErr);initErrCalculated=true;}let bufferedSec=0;if(audio.buffered.length>0){bufferedSec=audio.buffered.end(audio.buffered.length-1)-localSec;}bufferedEl.textContent=bufferedSec.toFixed(1);playRateEl.textContent=audio.playbackRate.toFixed(3);if(audio.paused)await safePlay();// ONE initial seek when track starts and metadata is ready
if(needInitialSeek){
if(haveMetadata&&!audio.paused&&Number.isFinite(audio.duration)&&audio.duration>0){
audio.currentTime=Math.max(0,Math.min(audio.duration-0.05,targetSec));
audio.playbackRate=1.0;
integralError=0;
lastPlaybackRate=1.0;
needInitialSeek=false;
hardSeekStrike=0;
posHistory=[];
return;
}else{
audio.playbackRate=1.0;
return;
}
}

// If metadata not ready, do nothing
if(!haveMetadata||!Number.isFinite(audio.duration)||audio.duration<=0){
audio.playbackRate=1.0;
return;
}

// Hard seek if persistently way off (reduced threshold for light show timing)
const HARD_SEEK_MS=800;
const HARD_SEEK_STRIKES=2;
if(Math.abs(errMs)>HARD_SEEK_MS){
hardSeekStrike++;
if(hardSeekStrike>=HARD_SEEK_STRIKES){
audio.currentTime=Math.max(0,Math.min(audio.duration-0.05,targetSec));
audio.playbackRate=1.0;
integralError=0;
lastPlaybackRate=1.0;
hardSeekStrike=0;
}
return;
}else{
hardSeekStrike=0;
}

// PI controller for normal drift - NO seeking
const DEAD=100; // Wider dead zone for stability
const MAX_RATE=1.15; // Â±15% for faster convergence
const MIN_RATE=0.85;
if(Math.abs(errMs)<=DEAD){
audio.playbackRate=1.0;
integralError*=0.5;
lastPlaybackRate=1.0;
return;
}

// PI with anti-windup
integralError+=errMs;
integralError=Math.max(-10000,Math.min(10000,integralError));

// More aggressive gains for light show timing
const Kp2=0.002; // 2.5x more aggressive
const Ki2=0.00003; // 3x more aggressive
const adjustment=(Kp2*errMs)+(Ki2*integralError);
const targetRate=clamp(1.0+adjustment,MIN_RATE,MAX_RATE);

// Faster response for light show sync
const SMOOTH=0.7; // 70% toward target (was 35%)
const smoothed=lastPlaybackRate+SMOOTH*(targetRate-lastPlaybackRate);
audio.playbackRate=smoothed;
lastPlaybackRate=smoothed;
}

// Fetch and display version (cache-busting)
fetch('/listen/version.php?t='+Date.now()).then(r=>r.text()).then(v=>document.getElementById('version').textContent='v'+v.trim()).catch(()=>{});

</script>

</body>

</html>