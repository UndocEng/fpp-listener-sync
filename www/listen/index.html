<!doctype html>

<html>

<head>

  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <title>Listen</title>

  <style>

    body { font-family: system-ui, sans-serif; margin: 0; padding: 18px; background: #111; color: #eee; }

    .header { text-align: center; margin-bottom: 16px; }

    .header img { width: 80px; height: 80px; }

    .header h2 { margin: 8px 0 4px 0; color: #00e5ff; font-size: 36px; font-weight: 700; }

    .small { opacity: .7; font-size: 14px; }

    button { font-size: 22px; padding: 14px 18px; width: 100%; border: 2px solid #00e5ff; border-radius: 10px; background: #222; color: #00e5ff; cursor: pointer; }

    button:disabled { opacity: 0.5; cursor: default; }

    .idle-msg { text-align: center; margin-top: 24px; padding: 20px; border: 1px solid #333; border-radius: 10px; background: #1a1a1a; color: #888; font-size: 16px; }

    .now-playing { text-align: center; margin-top: 16px; padding: 14px; border: 1px solid #00e5ff; border-radius: 10px; background: #0a1a1f; font-size: 18px; color: #00e5ff; }

    .debug-toggle { margin-top: 16px; font-size: 13px; opacity: 0.5; }

    .debug-toggle label { cursor: pointer; }

    .box { margin-top: 8px; padding: 12px; border: 1px solid #333; border-radius: 10px; background: #1a1a1a; font-size: 13px; color: #aaa; }

    .box b { color: #ccc; }

    .err { color: #f44; font-weight: 600; }

    .hidden { display: none; }

  </style>

</head>

<body>

  <div class="header">

    <img src="logo.png" alt="Undocumented Engineer" />

    <h2>Show Audio</h2>

    <p class="small" style="font-size: 11px; opacity: 0.6; margin-top: -4px;" id="version">v1.0.0</p>

    <p class="small">Tap once to enable audio. Keep this page open during the show.</p>

  </div>

  <button id="enableBtn">Enable Audio</button>

  <div id="idleMsg" class="idle-msg">No show is currently broadcasting.</div>

  <div id="nowPlaying" class="now-playing hidden">&#9835; Now Playing: <span id="trackName">-</span></div>

  <div class="err" id="fetchErr"></div>

  <div class="err" id="playErr"></div>

  <div class="debug-toggle"><label><input type="checkbox" id="debugCheck" /> Show Debug Data</label></div>

  <div id="debugBox" class="box hidden">

    <div><b>Transport:</b> <span id="transport">-</span></div>

    <div><b>RTT:</b> <span id="rtt">-</span> ms</div>

    <div><b>Clock Offset:</b> <span id="offset">-</span> ms</div>

    <div><b>Sequence:</b> <span id="seq">-</span></div>

    <div><b>State:</b> <span id="state">-</span></div>

    <div><b>Target:</b> <span id="target">-</span> ms</div>

    <div><b>Local:</b> <span id="local">-</span> ms</div>

    <div><b>Error:</b> <span id="err">-</span> ms</div>

    <div><b>Avg Error (2s):</b> <span id="avgErr2s">-</span> ms</div>

    <div><b>Avg Error (all):</b> <span id="avgErrAll">-</span> ms</div>

    <div><b>Playback Rate:</b> <span id="playRate">1.0</span></div>

    <div><b>Buffered:</b> <span id="buffered">-</span> s</div>

  </div>

  <div id="logControls" class="hidden" style="margin-top:8px;text-align:right;">
    <button id="copyLogBtn" style="font-size:12px;padding:4px 10px;width:auto;border:1px solid #555;background:#222;color:#aaa;">Copy Log</button>
    <button id="clearLogBtn" style="font-size:12px;padding:4px 10px;width:auto;border:1px solid #555;background:#222;color:#aaa;">Clear Log</button>
  </div>
  <div id="logBox" class="box hidden" style="max-height:200px;overflow-y:auto;font-family:monospace;font-size:11px;white-space:pre-wrap;"></div>

  <audio id="audio" preload="auto" playsinline></audio>

<script>

// --- DOM References ---
const enableBtn=document.getElementById('enableBtn'),
audio=document.getElementById('audio'),
idleMsg=document.getElementById('idleMsg'),
nowPlaying=document.getElementById('nowPlaying'),
trackName=document.getElementById('trackName'),
pollEl=document.getElementById('transport'),
fetchErrEl=document.getElementById('fetchErr'),
playErrEl=document.getElementById('playErr'),
seqEl=document.getElementById('seq'),
stateEl=document.getElementById('state'),
targetEl=document.getElementById('target'),
localEl=document.getElementById('local'),
errEl=document.getElementById('err'),
avgErr2sEl=document.getElementById('avgErr2s'),
avgErrAllEl=document.getElementById('avgErrAll'),
playRateEl=document.getElementById('playRate'),
bufferedEl=document.getElementById('buffered'),
rttEl=document.getElementById('rtt'),
offsetEl=document.getElementById('offset'),
debugCheck=document.getElementById('debugCheck'),
debugBox=document.getElementById('debugBox');

// --- State ---
let enabled=false, currentBase="", pollTimer=null, haveMetadata=false, needInitialSeek=false, lastSeekMs=0, settleUntil=0, syncBusy=false;

// --- WebSocket ---
const WS_RECONNECT_MS=2000;
const WS_PING_INTERVAL_MS=3000;
const HTTP_POLL_MS=250;

let ws=null, wsConnected=false, wsPingTimer=null, wsReconnectTimer=null;

// --- Clock offset estimation ---
let clockOffset=0, clockOffsetValid=false;
const RTT_HISTORY_SIZE=5;
const OFFSET_HISTORY_SIZE=8;
let rttHistory=[];
let offsetHistory=[];

// --- Error tracking ---
let errHistory2s=[], errHistoryAll=[];
const ERR_2S_SIZE=8;
let logThrottle=0;

// --- Helpers ---
function clamp(v,lo,hi){return Math.max(lo,Math.min(hi,v));}

const logBox=document.getElementById('logBox');
const LOG_MAX=200;
let logCount=0;
function log(msg){
  if(!debugCheck.checked)return;
  const t=new Date();
  const ts=t.toTimeString().slice(0,8)+'.'+String(t.getMilliseconds()).padStart(3,'0');
  const line=ts+' '+msg+'\n';
  logBox.textContent+=line;
  logCount++;
  if(logCount>LOG_MAX){
    const lines=logBox.textContent.split('\n');
    logBox.textContent=lines.slice(-LOG_MAX).join('\n');
    logCount=LOG_MAX;
  }
  logBox.scrollTop=logBox.scrollHeight;
}

const logControls=document.getElementById('logControls');
debugCheck.addEventListener('change',()=>{
  const show=debugCheck.checked;
  debugBox.classList.toggle('hidden',!show);
  logBox.classList.toggle('hidden',!show);
  logControls.classList.toggle('hidden',!show);
});
document.getElementById('copyLogBtn').onclick=()=>{
  if(navigator.clipboard){navigator.clipboard.writeText(logBox.textContent).then(()=>{document.getElementById('copyLogBtn').textContent='Copied!';setTimeout(()=>{document.getElementById('copyLogBtn').textContent='Copy Log';},1500);});}
};
document.getElementById('clearLogBtn').onclick=()=>{logBox.textContent='';logCount=0;};
audio.addEventListener('loadedmetadata',()=>{haveMetadata=true;log('METADATA loaded');});
audio.addEventListener('error',()=>{playErrEl.textContent="No matching audio file detected";log('AUDIO ERROR');});

// === Shared Clock Offset ===

function updateClockOffset(serverTs, clientSendTs, rtt){
  // NTP-style: offset = serverTs - clientSendTs - rtt/2
  const sample=serverTs-clientSendTs-(rtt/2);

  offsetHistory.push(sample);
  if(offsetHistory.length>OFFSET_HISTORY_SIZE)offsetHistory.shift();

  // Median filter to reject outliers, then EWMA smooth
  const sorted=[...offsetHistory].sort((a,b)=>a-b);
  const median=sorted[Math.floor(sorted.length/2)];

  if(!clockOffsetValid){
    clockOffset=median;
    clockOffsetValid=true;
  }else{
    clockOffset=clockOffset*0.7+median*0.3;
  }
  offsetEl.textContent=Math.round(clockOffset);
}

// === WebSocket Connection ===

function connectWebSocket(){
  if(ws&&(ws.readyState===WebSocket.CONNECTING||ws.readyState===WebSocket.OPEN))return;
  const wsUrl='ws://'+location.hostname+'/ws';
  try{ws=new WebSocket(wsUrl);}catch(e){startHttpFallback();return;}

  ws.onopen=()=>{
    wsConnected=true;
    stopHttpPolling();
    // Flush any bad HTTP-based offset samples (PHP 32-bit intval overflow)
    offsetHistory=[];
    clockOffsetValid=false;
    clockOffset=0;
    pollEl.textContent='WebSocket connected';
    fetchErrEl.textContent='';
    wsPingTimer=setInterval(sendPing,WS_PING_INTERVAL_MS);
    sendPing();
    log('WS CONNECTED, offset reset');
  };

  ws.onmessage=(event)=>{
    try{
      const data=JSON.parse(event.data);
      if(data.type==='pong'){
        handlePong(data);
      }else if(data.state!==undefined){
        sync(data);
      }
    }catch(e){}
  };

  ws.onclose=()=>{
    log('WS DISCONNECTED, falling back to HTTP');
    wsConnected=false;
    if(wsPingTimer){clearInterval(wsPingTimer);wsPingTimer=null;}
    pollEl.textContent='WS disconnected, HTTP fallback';
    startHttpFallback();
    if(wsReconnectTimer)clearTimeout(wsReconnectTimer);
    wsReconnectTimer=setTimeout(connectWebSocket,WS_RECONNECT_MS);
  };

  ws.onerror=()=>{};
}

function sendPing(){
  if(ws&&ws.readyState===WebSocket.OPEN){
    ws.send(JSON.stringify({type:'ping',client_ts:Date.now()}));
  }
}

function handlePong(data){
  const now=Date.now();
  const clientTs=data.client_ts;
  const serverTs=data.server_ts;
  const rtt=now-clientTs;

  if(rtt>0&&rtt<500){
    rttHistory.push(rtt);
    if(rttHistory.length>RTT_HISTORY_SIZE)rttHistory.shift();
    rttEl.textContent=rtt;
    updateClockOffset(serverTs,clientTs,rtt);
    log('PONG rtt='+rtt+'ms offset='+Math.round(clockOffset)+'ms');
  }else{
    log('PONG REJECTED rtt='+rtt+'ms (out of range)');
  }
}

// === HTTP Fallback Polling ===

function startHttpFallback(){
  if(pollTimer)return;
  pollTimer=setInterval(pollOnce,HTTP_POLL_MS);
  pollOnce();
}

function stopHttpPolling(){
  if(pollTimer){clearInterval(pollTimer);pollTimer=null;}
}

async function pollOnce(){
  if(!enabled)return;
  const t0=Date.now();
  try{
    const url=location.origin+'/listen/status.php?ts='+Date.now();
    const r=await fetch(url,{cache:'no-store'});
    if(!r.ok)throw new Error('HTTP '+r.status);
    const msg=await r.json();
    const t1=Date.now();
    const rtt=t1-t0;
    if(!wsConnected)pollEl.textContent='HTTP ok ('+rtt+' ms)';
    fetchErrEl.textContent='';

    // HTTP-based clock offset estimation using server_ms from status.php
    if(msg.server_ms&&rtt>0&&rtt<500){
      updateClockOffset(msg.server_ms,t0,rtt);
      if(!wsConnected)rttEl.textContent=rtt;
    }

    sync(msg);
  }catch(e){
    if(!wsConnected)pollEl.textContent='HTTP FAILED';
    fetchErrEl.textContent='Fetch error: '+(e?.message||e);
  }
}

// === Audio Playback ===

async function safePlay(){
  try{
    const p=audio.play();
    if(p&&typeof p.catch==='function'){await p;}
    playErrEl.textContent='';
  }catch(e){
    playErrEl.textContent='Audio playback blocked: '+(e?.message||e);
  }
}

// === Enable Button ===

enableBtn.onclick=()=>{
  enabled=true;
  enableBtn.disabled=true;
  enableBtn.textContent='Audio Enabled';
  pollEl.textContent='Connecting...';

  // Try WebSocket first, HTTP polling as immediate fallback
  connectWebSocket();
  startHttpFallback();

  // Audio unlock gesture
  try{
    audio.muted=true;
    const p=audio.play();
    if(p&&typeof p.then==='function'){
      p.then(()=>{audio.pause();audio.currentTime=0;audio.muted=false;})
      .catch(()=>{audio.muted=false;});
    }else{audio.muted=false;}
  }catch(e){audio.muted=false;}
};

// Reconnect WebSocket when page becomes visible again
document.addEventListener('visibilitychange',()=>{
  if(document.visibilityState==='visible'&&enabled&&!wsConnected){
    connectWebSocket();
  }
});

// === Sync Algorithm ===

async function sync(msg){
  // FIX #1: Sync guard - prevent overlapping async calls from fighting
  if(syncBusy)return;
  syncBusy=true;
  try{await syncInner(msg);}finally{syncBusy=false;}
}

async function syncInner(msg){
  seqEl.textContent=msg.base||'-';
  stateEl.textContent=msg.state||'-';
  targetEl.textContent=msg.pos_ms??'-';

  if(msg.state==='stop'||!msg.base){
    idleMsg.classList.remove('hidden');
    nowPlaying.classList.add('hidden');
    playErrEl.textContent='';
  }else{
    idleMsg.classList.add('hidden');
    nowPlaying.classList.remove('hidden');
    trackName.textContent=msg.base;
  }

  // Track change
  if(msg.base&&msg.base!==currentBase){
    log('TRACK CHANGE: '+msg.base+' src='+msg.mp3_url);
    currentBase=msg.base;
    haveMetadata=false;
    needInitialSeek=true;
    audio.playbackRate=1.0;
    audio.src=msg.mp3_url||'';
    audio.load();
    errHistory2s=[];
    errHistoryAll=[];
  }

  // Stop
  if(msg.state==='stop'){
    log('STATE: stop');
    audio.pause();
    audio.currentTime=0;
    audio.playbackRate=1.0;
    errHistory2s=[];
    errHistoryAll=[];
    needInitialSeek=false;
    return;
  }

  // Pause
  if(msg.state==='pause'){
    log('STATE: pause');
    audio.pause();
    audio.playbackRate=1.0;
    errHistory2s=[];
    errHistoryAll=[];
    needInitialSeek=false;
    return;
  }

  // Start playback if needed (do this BEFORE time calculation to avoid stale reads)
  if(audio.paused){log('PLAY resuming (was paused)');await safePlay();}

  // --- Time calculation with clock offset ---
  const nowMs=Date.now();
  const serverMs=Number(msg.server_ms);
  const rawPosMs=Number(msg.pos_ms||0);

  // Always extrapolate position forward from when server sampled it
  // Validate serverMs looks like epoch-ms and isn't wildly off
  let targetMs=rawPosMs;
  const serverOk=Number.isFinite(serverMs)&&serverMs>1e12&&Math.abs(nowMs-serverMs)<300000;
  if(serverOk){
    let elapsed;
    if(clockOffsetValid){
      elapsed=(nowMs+clockOffset)-serverMs;
    }else{
      elapsed=nowMs-serverMs;
    }
    if(!Number.isFinite(elapsed))elapsed=0;
    elapsed=clamp(elapsed,0,1500);
    targetMs=rawPosMs+elapsed;
  }else{
    log('SERVER_MS INVALID: '+serverMs+' nowMs='+nowMs+' diff='+Math.abs(nowMs-serverMs));
  }

  const targetSec=targetMs/1000.0;
  const localSec=audio.currentTime||0;
  const errMs=(targetSec-localSec)*1000.0;

  // FIX #3: Don't compute or record error during settle (it's garbage after a seek)
  if(Date.now()<settleUntil){
    // Update display but don't record history or adjust anything
    localEl.textContent=Math.round(localSec*1000);
    errEl.textContent='(settling)';
    playRateEl.textContent=audio.playbackRate.toFixed(3);
    audio.playbackRate=1.0;
    if(++logThrottle%10===0)log('SETTLE remaining='+(settleUntil-Date.now())+'ms err='+Math.round(errMs)+'ms');
    return;
  }

  // Update debug display
  localEl.textContent=Math.round(localSec*1000);
  errEl.textContent=Math.round(errMs);

  errHistory2s.push(errMs);
  if(errHistory2s.length>ERR_2S_SIZE)errHistory2s.shift();
  errHistoryAll.push(errMs);
  const avgErr2s=errHistory2s.length>0?(errHistory2s.reduce((a,b)=>a+b,0)/errHistory2s.length):0;
  const avgErrAll=errHistoryAll.length>0?(errHistoryAll.reduce((a,b)=>a+b,0)/errHistoryAll.length):0;
  avgErr2sEl.textContent=Math.round(avgErr2s);
  avgErrAllEl.textContent=Math.round(avgErrAll);

  let bufferedSec=0;
  if(audio.buffered.length>0){bufferedSec=audio.buffered.end(audio.buffered.length-1)-localSec;}
  bufferedEl.textContent=bufferedSec.toFixed(1);
  playRateEl.textContent=audio.playbackRate.toFixed(3);

  // Initial seek when track starts
  if(needInitialSeek&&!audio.paused){
    const seekTo=Math.max(0,Math.min(audio.duration||999999,targetSec));
    log('INITIAL SEEK to='+Math.round(seekTo*1000)+'ms target='+Math.round(targetMs)+'ms');
    audio.currentTime=seekTo;
    needInitialSeek=false;
    errHistory2s=[];
    errHistoryAll=[];
    settleUntil=Date.now()+1500;
    return;
  }

  if(!haveMetadata||!Number.isFinite(audio.duration)||audio.duration<=0){
    audio.playbackRate=1.0;
    return;
  }

  // Seek if off by more than 200ms - seeking is the primary correction
  if(Math.abs(errMs)>200){
    const now=Date.now();
    if(now-lastSeekMs>1500){
      const seekTo=Math.max(0,Math.min(audio.duration-0.05,targetSec));
      log('SEEK err='+Math.round(errMs)+'ms to='+Math.round(seekTo*1000)+'ms target='+Math.round(targetMs)+'ms local='+Math.round(localSec*1000)+'ms');
      audio.currentTime=seekTo;
      lastSeekMs=now;
      errHistory2s=[];
      errHistoryAll=[];
      settleUntil=now+1200;
    }else{
      log('SEEK BLOCKED err='+Math.round(errMs)+'ms cooldown='+(1500-(now-lastSeekMs))+'ms');
    }
    audio.playbackRate=1.0;
    return;
  }

  // Dead zone: if within 30ms, playback rate stays exactly 1.0
  if(Math.abs(errMs)<30){
    if(audio.playbackRate!==1.0)log('DEADZONE err='+Math.round(errMs)+'ms rate→1.000');
    audio.playbackRate=1.0;
    return;
  }

  // Tiny rate nudges only for 30-200ms range
  // Gain 0.00002: at 100ms → 0.2%, at 200ms → 0.4%
  // Clamp ±0.5% - playback rate stays between 0.995 and 1.005
  const adjustment=errMs*0.00002;
  const newRate=clamp(1.0+adjustment,0.995,1.005);
  audio.playbackRate=newRate;
  if(++logThrottle%10===0)log('RATE err='+Math.round(errMs)+'ms rate='+newRate.toFixed(4)+' adj='+(adjustment*100).toFixed(3)+'%');
}

// Fetch and display version (cache-busting)
fetch('/listen/version.php?t='+Date.now()).then(r=>r.text()).then(v=>document.getElementById('version').textContent='v'+v.trim()).catch(()=>{});

</script>

</body>

</html>
