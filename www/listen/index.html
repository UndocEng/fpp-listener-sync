<!doctype html>

<html>

<head>

  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <title>Listen</title>

  <style>

    body { font-family: system-ui, sans-serif; margin: 0; padding: 18px; background: #111; color: #eee; }

    .header { text-align: center; margin-bottom: 16px; }

    .header img { width: 80px; height: 80px; }

    .header h2 { margin: 8px 0 4px 0; color: #00e5ff; font-size: 36px; font-weight: 700; }

    .small { opacity: .7; font-size: 14px; }

    button { font-size: 22px; padding: 14px 18px; width: 100%; border: 2px solid #00e5ff; border-radius: 10px; background: #222; color: #00e5ff; cursor: pointer; }

    button:disabled { opacity: 0.5; cursor: default; }

    .idle-msg { text-align: center; margin-top: 24px; padding: 20px; border: 1px solid #333; border-radius: 10px; background: #1a1a1a; color: #888; font-size: 16px; }

    .now-playing { text-align: center; margin-top: 16px; padding: 14px; border: 1px solid #00e5ff; border-radius: 10px; background: #0a1a1f; font-size: 18px; color: #00e5ff; }

    .debug-toggle { margin-top: 16px; font-size: 13px; opacity: 0.5; }

    .debug-toggle label { cursor: pointer; }

    .box { margin-top: 8px; padding: 12px; border: 1px solid #333; border-radius: 10px; background: #1a1a1a; font-size: 13px; color: #aaa; }

    .box b { color: #ccc; }

    .err { color: #f44; font-weight: 600; }

    .hidden { display: none; }

  </style>

</head>

<body>

  <div class="header">

    <img src="logo.png" alt="Undocumented Engineer" />

    <h2>Show Audio</h2>

    <p class="small" style="font-size: 11px; opacity: 0.6; margin-top: -4px;" id="version">v1.0.0</p>

    <p class="small">Tap once to enable audio. Keep this page open during the show.</p>

  </div>

  <button id="enableBtn">Enable Audio</button>

  <div id="idleMsg" class="idle-msg">No show is currently broadcasting.</div>

  <div id="nowPlaying" class="now-playing hidden">&#9835; Now Playing: <span id="trackName">-</span></div>

  <div class="err" id="fetchErr"></div>

  <div class="err" id="playErr"></div>

  <div class="debug-toggle"><label><input type="checkbox" id="debugCheck" /> Show Debug Data</label> &nbsp; <label><input type="checkbox" id="logCheck" /> Enable Logging</label></div>

  <div id="debugBox" class="box hidden">

    <div><b>Transport:</b> <span id="transport">-</span></div>

    <div><b>RTT:</b> <span id="rtt">-</span> ms</div>

    <div><b>Clock Offset:</b> <span id="offset">-</span> ms</div>

    <div><b>Sequence:</b> <span id="seq">-</span></div>

    <div><b>State:</b> <span id="state">-</span></div>

    <div><b>Target:</b> <span id="target">-</span> ms</div>

    <div><b>Local:</b> <span id="local">-</span> ms</div>

    <div><b>Error:</b> <span id="err">-</span> ms</div>

    <div><b>Avg Error (2s):</b> <span id="avgErr2s">-</span> ms</div>

    <div><b>Avg Error (all):</b> <span id="avgErrAll">-</span> ms</div>

    <div><b>Playback Rate:</b> <span id="playRate">1.0</span></div>

    <div><b>Effective Rate:</b> <span id="effRate">-</span></div>

    <div><b>Sync Phase:</b> <span id="syncPhase">IDLE</span></div>

    <div><b>Stored Rate:</b> <span id="storedRate">-</span></div>

    <div><b>Buffered:</b> <span id="buffered">-</span> s</div>

  </div>

  <div id="logControls" class="hidden" style="margin-top:8px;text-align:right;">
    <span id="logStatus" style="font-size:11px;color:#f90;margin-right:8px;"></span>
    <button id="resumeLogBtn" style="font-size:12px;padding:4px 10px;width:auto;border:1px solid #555;background:#222;color:#aaa;display:none;">Resume Log</button>
    <button id="copyLogBtn" style="font-size:12px;padding:4px 10px;width:auto;border:1px solid #555;background:#222;color:#aaa;">Copy Log</button>
    <button id="clearLogBtn" style="font-size:12px;padding:4px 10px;width:auto;border:1px solid #555;background:#222;color:#aaa;">Clear Log</button>
  </div>
  <div id="logBox" class="box hidden" style="max-height:200px;overflow-y:auto;font-family:monospace;font-size:11px;white-space:pre-wrap;"></div>

  <audio id="audio" preload="auto" playsinline></audio>

<script>

// --- DOM References ---
const enableBtn=document.getElementById('enableBtn'),
audio=document.getElementById('audio'),
idleMsg=document.getElementById('idleMsg'),
nowPlaying=document.getElementById('nowPlaying'),
trackName=document.getElementById('trackName'),
pollEl=document.getElementById('transport'),
fetchErrEl=document.getElementById('fetchErr'),
playErrEl=document.getElementById('playErr'),
seqEl=document.getElementById('seq'),
stateEl=document.getElementById('state'),
targetEl=document.getElementById('target'),
localEl=document.getElementById('local'),
errEl=document.getElementById('err'),
avgErr2sEl=document.getElementById('avgErr2s'),
avgErrAllEl=document.getElementById('avgErrAll'),
playRateEl=document.getElementById('playRate'),
effRateEl=document.getElementById('effRate'),
syncPhaseEl=document.getElementById('syncPhase'),
storedRateEl=document.getElementById('storedRate'),
bufferedEl=document.getElementById('buffered'),
rttEl=document.getElementById('rtt'),
offsetEl=document.getElementById('offset'),
debugCheck=document.getElementById('debugCheck'),
debugBox=document.getElementById('debugBox');

// --- State ---
let enabled=false, currentBase="", pollTimer=null, haveMetadata=false, needInitialSeek=false, lastSeekMs=0, settleUntil=0, syncBusy=false;
let logFrozen=false, wasPlaying=false;
let pendingMsg=null, playAttempting=false;

// --- WebSocket ---
const WS_RECONNECT_MS=2000;
const WS_PING_INTERVAL_MS=3000;
const HTTP_POLL_MS=250;

let ws=null, wsConnected=false, wsPingTimer=null, wsReconnectTimer=null;

// --- Clock offset estimation ---
let clockOffset=0, clockOffsetValid=false;
const RTT_HISTORY_SIZE=5;
const OFFSET_HISTORY_SIZE=8;
let rttHistory=[];
let offsetHistory=[];

// --- Error tracking ---
let errHistory2s=[], errHistoryAll=[];
const ERR_2S_SIZE=8;
let logThrottle=0;

// --- Calibrate-then-apply sync ---
// Phase state machine: IDLE → ACQUIRE → CALIBRATE → LOCKED
// ACQUIRE: initial seek done, waiting for settle
// CALIBRATE: measuring drift at rate=1.0 for 3 seconds
// LOCKED: holding calibrated rate, only re-seek on large error
let syncPhase='IDLE';
let calStartWall=0, calStartErr=0, calSamples=[];
const CAL_DURATION_MS=3000;
let calibratedRate=1.0;
let emergencySeekCount=0;

// --- Effective rate measurement ---
let effRateWallMs=0, effRateLocalMs=0, lastEffRate=0;

// --- Stored rate (localStorage per device) ---
const RATE_STORAGE_KEY='fpp-sync-rate';
function loadStoredRate(){
  try{
    const v=localStorage.getItem(RATE_STORAGE_KEY);
    if(v===null)return null;
    const r=parseFloat(v);
    return(r>0.9&&r<1.1)?r:null;
  }catch(e){return null;}
}
function saveRate(rate){
  try{localStorage.setItem(RATE_STORAGE_KEY,rate.toFixed(6));}catch(e){}
}
let storedRate=loadStoredRate();
if(storedRate!==null)storedRateEl.textContent=storedRate.toFixed(4);

// --- Helpers ---
function clamp(v,lo,hi){return Math.max(lo,Math.min(hi,v));}

const logBox=document.getElementById('logBox');
const LOG_MAX=200;
let logCount=0;
const logCheck=document.getElementById('logCheck');
function log(msg){
  if(!logCheck.checked||logFrozen)return;
  const t=new Date();
  const ts=t.toTimeString().slice(0,8)+'.'+String(t.getMilliseconds()).padStart(3,'0');
  const line=ts+' '+msg+'\n';
  logBox.textContent+=line;
  logCount++;
  if(logCount>LOG_MAX){
    const lines=logBox.textContent.split('\n');
    logBox.textContent=lines.slice(-LOG_MAX).join('\n');
    logCount=LOG_MAX;
  }
  logBox.scrollTop=logBox.scrollHeight;
}

// --- Server-side reporting (always on, minimal overhead) ---
const REPORT_INTERVAL_MS=2000;
let lastReportMs=0;
// Latest positions for inclusion in reports
let lastRawPosMs=0, lastTargetMs=0, lastLocalMs=0;
function sendReport(event,errMs,rate){
  if(!ws||ws.readyState!==WebSocket.OPEN)return;
  const now=Date.now();
  const immediate=event==='SEEK'||event==='TRACK'||event==='INITIAL_SEEK'||event==='STOP'||event==='CAL_START'||event==='CAL_DONE'||event==='RECAL';
  if(!immediate&&(now-lastReportMs)<REPORT_INTERVAL_MS)return;
  lastReportMs=now;
  ws.send(JSON.stringify({
    type:'report',
    event:event,
    fpp:Math.round(lastRawPosMs),
    target:Math.round(lastTargetMs),
    local:Math.round(lastLocalMs),
    err:Math.round(errMs||0),
    rate:Number((rate||1.0).toFixed(4)),
    eff:Number((lastEffRate||0).toFixed(3)),
    offset:Math.round(clockOffset),
    track:currentBase||''
  }));
}

const logControls=document.getElementById('logControls');
debugCheck.addEventListener('change',()=>{
  debugBox.classList.toggle('hidden',!debugCheck.checked);
});
logCheck.addEventListener('change',()=>{
  const show=logCheck.checked;
  logBox.classList.toggle('hidden',!show);
  logControls.classList.toggle('hidden',!show);
});
document.getElementById('copyLogBtn').onclick=()=>{
  if(navigator.clipboard){navigator.clipboard.writeText(logBox.textContent).then(()=>{document.getElementById('copyLogBtn').textContent='Copied!';setTimeout(()=>{document.getElementById('copyLogBtn').textContent='Copy Log';},1500);});}
};
document.getElementById('clearLogBtn').onclick=()=>{logBox.textContent='';logCount=0;logFrozen=false;document.getElementById('logStatus').textContent='';document.getElementById('resumeLogBtn').style.display='none';};
document.getElementById('resumeLogBtn').onclick=()=>{logFrozen=false;document.getElementById('logStatus').textContent='';document.getElementById('resumeLogBtn').style.display='none';log('--- LOG RESUMED ---');};
audio.addEventListener('loadedmetadata',()=>{haveMetadata=true;log('METADATA loaded');});
audio.addEventListener('error',()=>{playErrEl.textContent="No matching audio file detected";log('AUDIO ERROR');});

// === Shared Clock Offset ===

function updateClockOffset(serverTs, clientSendTs, rtt){
  // NTP-style: offset = serverTs - clientSendTs - rtt/2
  const sample=serverTs-clientSendTs-(rtt/2);

  offsetHistory.push(sample);
  if(offsetHistory.length>OFFSET_HISTORY_SIZE)offsetHistory.shift();

  // Median filter to reject outliers, then EWMA smooth
  const sorted=[...offsetHistory].sort((a,b)=>a-b);
  const median=sorted[Math.floor(sorted.length/2)];

  if(!clockOffsetValid){
    clockOffset=median;
    clockOffsetValid=true;
  }else{
    clockOffset=clockOffset*0.7+median*0.3;
  }
  offsetEl.textContent=Math.round(clockOffset);
}

// === WebSocket Connection ===

function connectWebSocket(){
  if(ws&&(ws.readyState===WebSocket.CONNECTING||ws.readyState===WebSocket.OPEN))return;
  const wsUrl='ws://'+location.hostname+'/ws';
  try{ws=new WebSocket(wsUrl);}catch(e){startHttpFallback();return;}

  ws.onopen=()=>{
    wsConnected=true;
    stopHttpPolling();
    // Flush any bad HTTP-based offset samples (PHP 32-bit intval overflow)
    offsetHistory=[];
    clockOffsetValid=false;
    clockOffset=0;
    pollEl.textContent='WebSocket connected';
    fetchErrEl.textContent='';
    wsPingTimer=setInterval(sendPing,WS_PING_INTERVAL_MS);
    sendPing();
    log('WS CONNECTED, offset reset');
  };

  ws.onmessage=(event)=>{
    try{
      const data=JSON.parse(event.data);
      if(data.type==='pong'){
        handlePong(data);
      }else if(data.state!==undefined){
        sync(data);
      }
    }catch(e){}
  };

  ws.onclose=()=>{
    log('WS DISCONNECTED, falling back to HTTP');
    wsConnected=false;
    if(wsPingTimer){clearInterval(wsPingTimer);wsPingTimer=null;}
    pollEl.textContent='WS disconnected, HTTP fallback';
    startHttpFallback();
    if(wsReconnectTimer)clearTimeout(wsReconnectTimer);
    wsReconnectTimer=setTimeout(connectWebSocket,WS_RECONNECT_MS);
  };

  ws.onerror=()=>{};
}

function sendPing(){
  if(ws&&ws.readyState===WebSocket.OPEN){
    ws.send(JSON.stringify({type:'ping',client_ts:Date.now()}));
  }
}

function handlePong(data){
  const now=Date.now();
  const clientTs=data.client_ts;
  const serverTs=data.server_ts;
  const rtt=now-clientTs;

  if(rtt>0&&rtt<500){
    rttHistory.push(rtt);
    if(rttHistory.length>RTT_HISTORY_SIZE)rttHistory.shift();
    rttEl.textContent=rtt;
    updateClockOffset(serverTs,clientTs,rtt);
    log('PONG rtt='+rtt+'ms offset='+Math.round(clockOffset)+'ms');
  }else{
    log('PONG REJECTED rtt='+rtt+'ms (out of range)');
  }
}

// === HTTP Fallback Polling ===

function startHttpFallback(){
  if(pollTimer)return;
  pollTimer=setInterval(pollOnce,HTTP_POLL_MS);
  pollOnce();
}

function stopHttpPolling(){
  if(pollTimer){clearInterval(pollTimer);pollTimer=null;}
}

async function pollOnce(){
  if(!enabled)return;
  const t0=Date.now();
  try{
    const url=location.origin+'/listen/status.php?ts='+Date.now();
    const r=await fetch(url,{cache:'no-store'});
    if(!r.ok)throw new Error('HTTP '+r.status);
    const msg=await r.json();
    const t1=Date.now();
    const rtt=t1-t0;
    if(!wsConnected)pollEl.textContent='HTTP ok ('+rtt+' ms)';
    fetchErrEl.textContent='';

    // HTTP-based clock offset estimation using server_ms from status.php
    if(msg.server_ms&&rtt>0&&rtt<500){
      updateClockOffset(msg.server_ms,t0,rtt);
      if(!wsConnected)rttEl.textContent=rtt;
    }

    sync(msg);
  }catch(e){
    if(!wsConnected)pollEl.textContent='HTTP FAILED';
    fetchErrEl.textContent='Fetch error: '+(e?.message||e);
  }
}

// === Audio Playback ===

async function safePlay(){
  try{
    const p=audio.play();
    if(p&&typeof p.catch==='function'){await p;}
    playErrEl.textContent='';
  }catch(e){
    playErrEl.textContent='Audio playback blocked: '+(e?.message||e);
  }
}

// === Enable Button ===

enableBtn.onclick=()=>{
  enabled=true;
  enableBtn.disabled=true;
  enableBtn.textContent='Audio Enabled';
  pollEl.textContent='Connecting...';

  // Try WebSocket first, HTTP polling as immediate fallback
  connectWebSocket();
  startHttpFallback();

  // Audio unlock gesture
  try{
    audio.muted=true;
    const p=audio.play();
    if(p&&typeof p.then==='function'){
      p.then(()=>{audio.pause();audio.currentTime=0;audio.muted=false;})
      .catch(()=>{audio.muted=false;});
    }else{audio.muted=false;}
  }catch(e){audio.muted=false;}
};

// Reconnect WebSocket when page becomes visible again
document.addEventListener('visibilitychange',()=>{
  if(document.visibilityState==='visible'&&enabled&&!wsConnected){
    connectWebSocket();
  }
});

// === Sync Algorithm ===

async function sync(msg){
  // Queue latest message instead of dropping - prevents stale drift
  // when syncInner is blocked (e.g. during safePlay)
  pendingMsg=msg;
  if(syncBusy)return;
  syncBusy=true;
  try{
    while(pendingMsg){
      const m=pendingMsg;
      pendingMsg=null;
      await syncInner(m);
    }
  }finally{syncBusy=false;}
}

async function syncInner(msg){
  seqEl.textContent=msg.base||'-';
  stateEl.textContent=msg.state||'-';
  targetEl.textContent=msg.pos_ms??'-';

  if(msg.state==='stop'||!msg.base){
    idleMsg.classList.remove('hidden');
    nowPlaying.classList.add('hidden');
    playErrEl.textContent='';
  }else{
    idleMsg.classList.add('hidden');
    nowPlaying.classList.remove('hidden');
    trackName.textContent=msg.base;
  }

  // Track change - auto-clear logs for fresh start
  if(msg.base&&msg.base!==currentBase){
    // Auto-clear phone log
    logBox.textContent='';logCount=0;logFrozen=false;
    document.getElementById('logStatus').textContent='';
    document.getElementById('resumeLogBtn').style.display='none';
    log('TRACK CHANGE: '+msg.base+' src='+msg.mp3_url);
    sendReport('TRACK',0,1.0);
    currentBase=msg.base;
    haveMetadata=false;
    needInitialSeek=true;
    audio.playbackRate=1.0;
    audio.src=msg.mp3_url||'';
    audio.load();
    errHistory2s=[];
    errHistoryAll=[];
    effRateWallMs=0;
    syncPhase='ACQUIRE';
    calSamples=[];
    emergencySeekCount=0;
    syncPhaseEl.textContent='ACQUIRE';
  }

  // Stop
  if(msg.state==='stop'){
    // Only log/report the transition once (server broadcasts stop every 100ms)
    if(wasPlaying){
      log('STATE: stop');
      sendReport('STOP',0,1.0);
      // Freeze log when song ends so user can grab it
      if(logCheck.checked){
        logFrozen=true;
        document.getElementById('logStatus').textContent='Log frozen (song ended)';
        document.getElementById('resumeLogBtn').style.display='';
      }
    }
    audio.pause();
    audio.currentTime=0;
    audio.playbackRate=1.0;
    errHistory2s=[];
    errHistoryAll=[];
    needInitialSeek=false;
    wasPlaying=false;
    syncPhase='IDLE';
    syncPhaseEl.textContent='IDLE';
    return;
  }

  // Pause
  if(msg.state==='pause'){
    log('STATE: pause');
    audio.pause();
    audio.playbackRate=1.0;
    errHistory2s=[];
    errHistoryAll=[];
    needInitialSeek=false;
    return;
  }

  wasPlaying=true;

  // Start playback if needed - fire-and-forget to avoid blocking sync loop
  if(audio.paused&&!playAttempting){
    log('PLAY resuming (was paused)');
    playAttempting=true;
    safePlay().finally(()=>{playAttempting=false;});
  }

  // --- Time calculation with clock offset ---
  const nowMs=Date.now();
  const serverMs=Number(msg.server_ms);
  const rawPosMs=Number(msg.pos_ms||0);

  // Always extrapolate position forward from when server sampled it
  // Validate serverMs looks like epoch-ms and isn't wildly off
  let targetMs=rawPosMs;
  const serverOk=Number.isFinite(serverMs)&&serverMs>1e12&&Math.abs(nowMs-serverMs)<300000;
  if(serverOk){
    let elapsed;
    if(clockOffsetValid){
      elapsed=(nowMs+clockOffset)-serverMs;
    }else{
      elapsed=nowMs-serverMs;
    }
    if(!Number.isFinite(elapsed))elapsed=0;
    elapsed=clamp(elapsed,0,1500);
    targetMs=rawPosMs+elapsed;
  }else{
    log('SERVER_MS INVALID: '+serverMs+' nowMs='+nowMs+' diff='+Math.abs(nowMs-serverMs));
  }

  const targetSec=targetMs/1000.0;
  const localSec=audio.currentTime||0;
  const errMs=(targetSec-localSec)*1000.0;

  // Store positions for server reports
  lastRawPosMs=rawPosMs;
  lastTargetMs=targetMs;
  lastLocalMs=localSec*1000;

  // FIX #3: Don't compute or record error during settle (it's garbage after a seek)
  if(Date.now()<settleUntil){
    // Update display but don't record history or adjust anything
    localEl.textContent=Math.round(localSec*1000);
    errEl.textContent='(settling)';
    playRateEl.textContent=audio.playbackRate.toFixed(4);
    if(syncPhase==='LOCKED')audio.playbackRate=calibratedRate;
    if(++logThrottle%10===0)log('SETTLE remaining='+(settleUntil-Date.now())+'ms phase='+syncPhase);
    return;
  }

  // Update debug display
  localEl.textContent=Math.round(localSec*1000);
  errEl.textContent=Math.round(errMs);

  errHistory2s.push(errMs);
  if(errHistory2s.length>ERR_2S_SIZE)errHistory2s.shift();
  errHistoryAll.push(errMs);
  if(errHistoryAll.length>100)errHistoryAll.shift();
  const avgErr2s=errHistory2s.length>0?(errHistory2s.reduce((a,b)=>a+b,0)/errHistory2s.length):0;
  const avgErrAll=errHistoryAll.length>0?(errHistoryAll.reduce((a,b)=>a+b,0)/errHistoryAll.length):0;
  avgErr2sEl.textContent=Math.round(avgErr2s);
  avgErrAllEl.textContent=Math.round(avgErrAll);

  let bufferedSec=0;
  if(audio.buffered.length>0){bufferedSec=audio.buffered.end(audio.buffered.length-1)-localSec;}
  bufferedEl.textContent=bufferedSec.toFixed(1);
  playRateEl.textContent=audio.playbackRate.toFixed(4);

  // Initial seek when track starts
  if(needInitialSeek&&!audio.paused&&haveMetadata){
    const seekTo=Math.max(0,Math.min(audio.duration-0.05,targetSec));
    log('INITIAL SEEK to='+Math.round(seekTo*1000)+'ms target='+Math.round(targetMs)+'ms');
    sendReport('INITIAL_SEEK',errMs,1.0);
    audio.currentTime=seekTo;
    needInitialSeek=false;
    errHistory2s=[];
    errHistoryAll=[];
    effRateWallMs=0;
    settleUntil=Date.now()+1500;
    return;
  }

  if(!haveMetadata||!Number.isFinite(audio.duration)||audio.duration<=0){
    audio.playbackRate=1.0;
    return;
  }

  // ====== PHASE-BASED SYNC (Calibrate Then Apply) ======
  // Instead of continuously adjusting playbackRate (which mobile browsers ignore),
  // we: measure drift at rate=1.0 for 3s, calculate ONE calibrated rate,
  // seek to fix accumulated error, then hold that rate forever.
  // The calibrated rate is saved to localStorage so the device remembers it.
  syncPhaseEl.textContent=syncPhase;

  // Phase: ACQUIRE - settle is done, decide next step
  if(syncPhase==='ACQUIRE'){
    audio.playbackRate=1.0;
    if(storedRate!==null){
      calibratedRate=storedRate;
      audio.playbackRate=calibratedRate;
      syncPhase='LOCKED';
      syncPhaseEl.textContent='LOCKED';
      effRateWallMs=Date.now();
      effRateLocalMs=localSec*1000;
      log('LOCKED (stored rate='+calibratedRate.toFixed(4)+')');
      sendReport('LOCKED',errMs,calibratedRate);
    }else{
      calStartWall=Date.now();
      calStartErr=errMs;
      calSamples=[{t:0,e:errMs}];
      syncPhase='CALIBRATE';
      syncPhaseEl.textContent='CALIBRATE';
      log('CALIBRATE started err='+Math.round(errMs)+'ms');
      sendReport('CAL_START',errMs,1.0);
    }
    return;
  }

  // Phase: CALIBRATE - measuring drift at rate=1.0
  if(syncPhase==='CALIBRATE'){
    audio.playbackRate=1.0;
    const calElapsed=Date.now()-calStartWall;
    calSamples.push({t:calElapsed,e:errMs});

    if(calElapsed<CAL_DURATION_MS){
      if(++logThrottle%10===0)log('CAL '+(calElapsed/1000).toFixed(1)+'/'+CAL_DURATION_MS/1000+'s err='+Math.round(errMs)+'ms');
      sendReport('CAL',errMs,1.0);
      return;
    }

    // Calibration complete - linear regression for robust drift estimate
    const n=calSamples.length;
    const sumX=calSamples.reduce((s,p)=>s+p.t,0);
    const sumY=calSamples.reduce((s,p)=>s+p.e,0);
    const sumXY=calSamples.reduce((s,p)=>s+p.t*p.e,0);
    const sumX2=calSamples.reduce((s,p)=>s+p.t*p.t,0);
    const denom=n*sumX2-sumX*sumX;
    const slope=denom!==0?(n*sumXY-sumX*sumY)/denom:0;
    // slope = ms_error_change per ms_wall → correction rate
    calibratedRate=clamp(1.0+slope,0.95,1.05);

    // Seek to fix accumulated error
    const seekTo=clamp(targetSec,0,audio.duration-0.05);
    audio.currentTime=seekTo;
    audio.playbackRate=calibratedRate;

    // Save to localStorage for this device
    saveRate(calibratedRate);
    storedRate=calibratedRate;
    storedRateEl.textContent=calibratedRate.toFixed(4);

    lastSeekMs=Date.now();
    settleUntil=Date.now()+1500;
    errHistory2s=[];
    errHistoryAll=[];
    effRateWallMs=0;
    syncPhase='LOCKED';
    syncPhaseEl.textContent='LOCKED';

    const driftPerSec=slope*1000;
    log('CAL DONE drift='+driftPerSec.toFixed(2)+'ms/s rate='+calibratedRate.toFixed(4)+' samples='+n);
    sendReport('CAL_DONE',errMs,calibratedRate);
    return;
  }

  // Phase: LOCKED - hold calibrated rate, monitor for problems
  if(syncPhase==='LOCKED'){
    audio.playbackRate=calibratedRate;

    // Measure effective rate for diagnostics
    const rateNow=Date.now();
    if(effRateWallMs>0){
      const dWall=rateNow-effRateWallMs;
      const dLocal=(localSec*1000)-effRateLocalMs;
      if(dWall>1000){
        lastEffRate=dLocal/dWall;
        effRateEl.textContent=lastEffRate.toFixed(4);
        effRateWallMs=rateNow;
        effRateLocalMs=localSec*1000;
      }
    }else{
      effRateWallMs=rateNow;
      effRateLocalMs=localSec*1000;
    }

    // Emergency re-seek (>2s error)
    if(Math.abs(errMs)>2000){
      const now=Date.now();
      if(now-lastSeekMs>5000){
        const seekTo=clamp(targetSec,0,audio.duration-0.05);
        audio.currentTime=seekTo;
        lastSeekMs=now;
        settleUntil=now+1500;
        errHistory2s=[];
        errHistoryAll=[];
        log('EMERGENCY SEEK err='+Math.round(errMs)+'ms');
        sendReport('SEEK',errMs,calibratedRate);
        // After 2 emergency seeks, stored rate is wrong - recalibrate
        if(++emergencySeekCount>=2){
          storedRate=null;
          try{localStorage.removeItem(RATE_STORAGE_KEY);}catch(e){}
          storedRateEl.textContent='(recal)';
          syncPhase='ACQUIRE';
          syncPhaseEl.textContent='ACQUIRE';
          emergencySeekCount=0;
          log('RECALIBRATE triggered');
          sendReport('RECAL',errMs,1.0);
        }
      }
      return;
    }

    // Nudge seek (500ms-2s error, max once per 10s)
    if(Math.abs(errMs)>500){
      const now=Date.now();
      if(now-lastSeekMs>10000){
        const seekTo=clamp(targetSec,0,audio.duration-0.05);
        audio.currentTime=seekTo;
        lastSeekMs=now;
        settleUntil=now+1500;
        log('NUDGE err='+Math.round(errMs)+'ms');
        sendReport('SEEK',errMs,calibratedRate);
      }
      return;
    }

    // Normal operation - periodic logging and reporting
    if(++logThrottle%20===0)log('LOCKED err='+Math.round(errMs)+'ms avg='+Math.round(avgErrAll)+'ms rate='+calibratedRate.toFixed(4)+' eff='+lastEffRate.toFixed(4));
    sendReport('LOCKED',errMs,calibratedRate);
  }
}

// Fetch and display version (cache-busting)
fetch('/listen/version.php?t='+Date.now()).then(r=>r.text()).then(v=>document.getElementById('version').textContent='v'+v.trim()).catch(()=>{});

</script>

</body>

</html>
