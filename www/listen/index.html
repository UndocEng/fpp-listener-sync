<!doctype html>

<html>

<head>

  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <title>Listen</title>

  <style>

    body { font-family: system-ui, sans-serif; margin: 0; padding: 18px; background: #111; color: #eee; }

    .header { text-align: center; margin-bottom: 16px; }

    .header img { width: 80px; height: 80px; }

    .header h2 { margin: 8px 0 4px 0; color: #00e5ff; font-size: 36px; font-weight: 700; }

    .small { opacity: .7; font-size: 14px; }

    button { font-size: 22px; padding: 14px 18px; width: 100%; border: 2px solid #00e5ff; border-radius: 10px; background: #222; color: #00e5ff; cursor: pointer; }

    button:disabled { opacity: 0.5; cursor: default; }

    .idle-msg { text-align: center; margin-top: 24px; padding: 20px; border: 1px solid #333; border-radius: 10px; background: #1a1a1a; color: #888; font-size: 16px; }

    .now-playing { text-align: center; margin-top: 16px; padding: 14px; border: 1px solid #00e5ff; border-radius: 10px; background: #0a1a1f; font-size: 18px; color: #00e5ff; }

    .debug-toggle { margin-top: 16px; font-size: 13px; opacity: 0.5; }

    .debug-toggle label { cursor: pointer; }

    .box { margin-top: 8px; padding: 12px; border: 1px solid #333; border-radius: 10px; background: #1a1a1a; font-size: 13px; color: #aaa; }

    .box b { color: #ccc; }

    .err { color: #f44; font-weight: 600; }

    .hidden { display: none; }

  </style>

</head>

<body>

  <div class="header">

    <img src="logo.png" alt="Undocumented Engineer" />

    <h2>Show Audio</h2>

    <p class="small" style="font-size: 11px; opacity: 0.6; margin-top: -4px;" id="version">v1.0.0</p>

    <p class="small">Tap once to enable audio. Keep this page open during the show.</p>

  </div>

  <button id="enableBtn">Enable Audio</button>

  <div id="idleMsg" class="idle-msg">No show is currently broadcasting.</div>

  <div id="nowPlaying" class="now-playing hidden">&#9835; Now Playing: <span id="trackName">-</span></div>

  <div class="err" id="fetchErr"></div>

  <div class="err" id="playErr"></div>

  <div class="debug-toggle"><label><input type="checkbox" id="debugCheck" /> Show Debug Data</label></div>

  <div id="debugBox" class="box hidden">

    <div><b>Transport:</b> <span id="transport">-</span></div>

    <div><b>RTT:</b> <span id="rtt">-</span> ms</div>

    <div><b>Clock Offset:</b> <span id="offset">-</span> ms</div>

    <div><b>Sequence:</b> <span id="seq">-</span></div>

    <div><b>State:</b> <span id="state">-</span></div>

    <div><b>Target:</b> <span id="target">-</span> ms</div>

    <div><b>Local:</b> <span id="local">-</span> ms</div>

    <div><b>Error:</b> <span id="err">-</span> ms</div>

    <div><b>Avg Error (2s):</b> <span id="avgErr2s">-</span> ms</div>

    <div><b>Avg Error (all):</b> <span id="avgErrAll">-</span> ms</div>

    <div><b>Playback Rate:</b> <span id="playRate">1.0</span></div>

    <div><b>Buffered:</b> <span id="buffered">-</span> s</div>

  </div>

  <audio id="audio" preload="auto" playsinline></audio>

<script>

// --- DOM References ---
const enableBtn=document.getElementById('enableBtn'),
audio=document.getElementById('audio'),
idleMsg=document.getElementById('idleMsg'),
nowPlaying=document.getElementById('nowPlaying'),
trackName=document.getElementById('trackName'),
pollEl=document.getElementById('transport'),
fetchErrEl=document.getElementById('fetchErr'),
playErrEl=document.getElementById('playErr'),
seqEl=document.getElementById('seq'),
stateEl=document.getElementById('state'),
targetEl=document.getElementById('target'),
localEl=document.getElementById('local'),
errEl=document.getElementById('err'),
avgErr2sEl=document.getElementById('avgErr2s'),
avgErrAllEl=document.getElementById('avgErrAll'),
playRateEl=document.getElementById('playRate'),
bufferedEl=document.getElementById('buffered'),
rttEl=document.getElementById('rtt'),
offsetEl=document.getElementById('offset'),
debugCheck=document.getElementById('debugCheck'),
debugBox=document.getElementById('debugBox');

// --- State ---
let enabled=false, currentBase="", pollTimer=null, haveMetadata=false, needInitialSeek=false;

// --- WebSocket ---
const WS_RECONNECT_MS=2000;
const WS_PING_INTERVAL_MS=3000;
const HTTP_POLL_MS=250;

let ws=null, wsConnected=false, wsPingTimer=null, wsReconnectTimer=null;

// --- Clock offset estimation ---
let clockOffset=0, clockOffsetValid=false;
const RTT_HISTORY_SIZE=5;
const OFFSET_HISTORY_SIZE=8;
let rttHistory=[];
let offsetHistory=[];

// --- Position averaging ---
let posHistory=[];
const POS_HISTORY_SIZE=2;

// --- Error tracking ---
let errHistory2s=[], errHistoryAll=[];
const ERR_2S_SIZE=8;

// --- Helpers ---
function clamp(v,lo,hi){return Math.max(lo,Math.min(hi,v));}

debugCheck.addEventListener('change',()=>{debugBox.classList.toggle('hidden',!debugCheck.checked);});
audio.addEventListener('loadedmetadata',()=>{haveMetadata=true;});
audio.addEventListener('error',()=>{playErrEl.textContent="No matching audio file detected";});

// === Shared Clock Offset ===

function updateClockOffset(serverTs, clientSendTs, rtt){
  // NTP-style: offset = serverTs - clientSendTs - rtt/2
  const sample=serverTs-clientSendTs-(rtt/2);

  offsetHistory.push(sample);
  if(offsetHistory.length>OFFSET_HISTORY_SIZE)offsetHistory.shift();

  // Median filter to reject outliers, then EWMA smooth
  const sorted=[...offsetHistory].sort((a,b)=>a-b);
  const median=sorted[Math.floor(sorted.length/2)];

  if(!clockOffsetValid){
    clockOffset=median;
    clockOffsetValid=true;
  }else{
    clockOffset=clockOffset*0.7+median*0.3;
  }
  offsetEl.textContent=Math.round(clockOffset);
}

// === WebSocket Connection ===

function connectWebSocket(){
  if(ws&&(ws.readyState===WebSocket.CONNECTING||ws.readyState===WebSocket.OPEN))return;
  const wsUrl='ws://'+location.hostname+'/ws';
  try{ws=new WebSocket(wsUrl);}catch(e){startHttpFallback();return;}

  ws.onopen=()=>{
    wsConnected=true;
    stopHttpPolling();
    pollEl.textContent='WebSocket connected';
    fetchErrEl.textContent='';
    wsPingTimer=setInterval(sendPing,WS_PING_INTERVAL_MS);
    sendPing();
  };

  ws.onmessage=(event)=>{
    try{
      const data=JSON.parse(event.data);
      if(data.type==='pong'){
        handlePong(data);
      }else if(data.state!==undefined){
        sync(data);
      }
    }catch(e){}
  };

  ws.onclose=()=>{
    wsConnected=false;
    if(wsPingTimer){clearInterval(wsPingTimer);wsPingTimer=null;}
    pollEl.textContent='WS disconnected, HTTP fallback';
    startHttpFallback();
    if(wsReconnectTimer)clearTimeout(wsReconnectTimer);
    wsReconnectTimer=setTimeout(connectWebSocket,WS_RECONNECT_MS);
  };

  ws.onerror=()=>{};
}

function sendPing(){
  if(ws&&ws.readyState===WebSocket.OPEN){
    ws.send(JSON.stringify({type:'ping',client_ts:Date.now()}));
  }
}

function handlePong(data){
  const now=Date.now();
  const clientTs=data.client_ts;
  const serverTs=data.server_ts;
  const rtt=now-clientTs;

  if(rtt>0&&rtt<500){
    rttHistory.push(rtt);
    if(rttHistory.length>RTT_HISTORY_SIZE)rttHistory.shift();
    rttEl.textContent=rtt;
    updateClockOffset(serverTs,clientTs,rtt);
  }
}

// === HTTP Fallback Polling ===

function startHttpFallback(){
  if(pollTimer)return;
  pollTimer=setInterval(pollOnce,HTTP_POLL_MS);
  pollOnce();
}

function stopHttpPolling(){
  if(pollTimer){clearInterval(pollTimer);pollTimer=null;}
}

async function pollOnce(){
  if(!enabled)return;
  const t0=Date.now();
  try{
    const url=location.origin+'/listen/status.php?ts='+Date.now();
    const r=await fetch(url,{cache:'no-store'});
    if(!r.ok)throw new Error('HTTP '+r.status);
    const msg=await r.json();
    const t1=Date.now();
    const rtt=t1-t0;
    if(!wsConnected)pollEl.textContent='HTTP ok ('+rtt+' ms)';
    fetchErrEl.textContent='';

    // HTTP-based clock offset estimation using server_ms from status.php
    if(msg.server_ms&&rtt>0&&rtt<500){
      updateClockOffset(msg.server_ms,t0,rtt);
      if(!wsConnected)rttEl.textContent=rtt;
    }

    sync(msg);
  }catch(e){
    if(!wsConnected)pollEl.textContent='HTTP FAILED';
    fetchErrEl.textContent='Fetch error: '+(e?.message||e);
  }
}

// === Audio Playback ===

async function safePlay(){
  try{
    const p=audio.play();
    if(p&&typeof p.catch==='function'){await p;}
    playErrEl.textContent='';
  }catch(e){
    playErrEl.textContent='Audio playback blocked: '+(e?.message||e);
  }
}

// === Enable Button ===

enableBtn.onclick=()=>{
  enabled=true;
  enableBtn.disabled=true;
  enableBtn.textContent='Audio Enabled';
  pollEl.textContent='Connecting...';

  // Try WebSocket first, HTTP polling as immediate fallback
  connectWebSocket();
  startHttpFallback();

  // Audio unlock gesture
  try{
    audio.muted=true;
    const p=audio.play();
    if(p&&typeof p.then==='function'){
      p.then(()=>{audio.pause();audio.currentTime=0;audio.muted=false;})
      .catch(()=>{audio.muted=false;});
    }else{audio.muted=false;}
  }catch(e){audio.muted=false;}
};

// Reconnect WebSocket when page becomes visible again
document.addEventListener('visibilitychange',()=>{
  if(document.visibilityState==='visible'&&enabled&&!wsConnected){
    connectWebSocket();
  }
});

// === Sync Algorithm ===

async function sync(msg){
  seqEl.textContent=msg.base||'-';
  stateEl.textContent=msg.state||'-';
  targetEl.textContent=msg.pos_ms??'-';

  if(msg.state==='stop'||!msg.base){
    idleMsg.classList.remove('hidden');
    nowPlaying.classList.add('hidden');
    playErrEl.textContent='';
  }else{
    idleMsg.classList.add('hidden');
    nowPlaying.classList.remove('hidden');
    trackName.textContent=msg.base;
  }

  // Track change
  if(msg.base&&msg.base!==currentBase){
    currentBase=msg.base;
    haveMetadata=false;
    needInitialSeek=true;
    audio.playbackRate=1.0;
    audio.src=msg.mp3_url||'';
    audio.load();
    posHistory=[];
    errHistory2s=[];
    errHistoryAll=[];
  }

  // Stop
  if(msg.state==='stop'){
    audio.pause();
    audio.currentTime=0;
    audio.playbackRate=1.0;
    posHistory=[];
    errHistory2s=[];
    errHistoryAll=[];
    needInitialSeek=false;
    return;
  }

  // Pause
  if(msg.state==='pause'){
    audio.pause();
    audio.playbackRate=1.0;
    posHistory=[];
    errHistory2s=[];
    errHistoryAll=[];
    needInitialSeek=false;
    return;
  }

  // --- Time calculation with clock offset ---
  const nowMs=Date.now();
  let serverMs=Number(msg.server_ms);

  let smoothPosMs;
  if(clockOffsetValid){
    // Convert client time to server time domain, then compute elapsed
    const clientAsServerTime=nowMs+clockOffset;
    smoothPosMs=Number(msg.pos_ms||0)+(clientAsServerTime-serverMs);
  }else{
    // Fallback: assume clocks are roughly aligned
    if(!Number.isFinite(serverMs)||serverMs<1000000000000||Math.abs(nowMs-serverMs)>5*60*1000){
      serverMs=nowMs;
    }
    smoothPosMs=Number(msg.pos_ms||0)+(nowMs-serverMs);
  }

  posHistory.push(smoothPosMs);
  if(posHistory.length>POS_HISTORY_SIZE)posHistory.shift();
  const avgPosMs=posHistory.reduce((a,b)=>a+b,0)/posHistory.length;
  const targetSec=avgPosMs/1000.0;
  const localSec=audio.currentTime||0;
  const errMs=(targetSec-localSec)*1000.0;

  // Update debug display
  localEl.textContent=Math.round(localSec*1000);
  errEl.textContent=Math.round(errMs);

  errHistory2s.push(errMs);
  if(errHistory2s.length>ERR_2S_SIZE)errHistory2s.shift();
  errHistoryAll.push(errMs);
  const avgErr2s=errHistory2s.length>0?(errHistory2s.reduce((a,b)=>a+b,0)/errHistory2s.length):0;
  const avgErrAll=errHistoryAll.length>0?(errHistoryAll.reduce((a,b)=>a+b,0)/errHistoryAll.length):0;
  avgErr2sEl.textContent=Math.round(avgErr2s);
  avgErrAllEl.textContent=Math.round(avgErrAll);

  let bufferedSec=0;
  if(audio.buffered.length>0){bufferedSec=audio.buffered.end(audio.buffered.length-1)-localSec;}
  bufferedEl.textContent=bufferedSec.toFixed(1);
  playRateEl.textContent=audio.playbackRate.toFixed(3);

  if(audio.paused)await safePlay();

  // Initial seek when track starts
  if(needInitialSeek&&!audio.paused){
    audio.currentTime=Math.max(0,Math.min(audio.duration||999999,targetSec));
    needInitialSeek=false;
    posHistory=[];
    return;
  }

  if(!haveMetadata||!Number.isFinite(audio.duration)||audio.duration<=0){
    audio.playbackRate=1.0;
    return;
  }

  // Emergency seek if very far off (>250ms)
  if(Math.abs(errMs)>250){
    audio.currentTime=Math.max(0,Math.min(audio.duration-0.05,targetSec));
    audio.playbackRate=1.0;
    return;
  }

  // Lock at 1.0 if close enough (<20ms)
  if(Math.abs(errMs)<20){
    audio.playbackRate=1.0;
    return;
  }

  // Proportional control: Â±2% max adjustment
  const adjustment=errMs*0.0005;
  audio.playbackRate=clamp(1.0+adjustment,0.98,1.02);
}

// Fetch and display version (cache-busting)
fetch('/listen/version.php?t='+Date.now()).then(r=>r.text()).then(v=>document.getElementById('version').textContent='v'+v.trim()).catch(()=>{});

</script>

</body>

</html>
